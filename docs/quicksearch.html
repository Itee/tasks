<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"tests_bundlings_check-bundling-from-esm-files-direct.task.mjs.html":{"id":"tests_bundlings_check-bundling-from-esm-files-direct.task.mjs.html","title":"Source: tests/bundlings/check-bundling-from-esm-files-direct.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/bundlings/check-bundling-from-esm-files-direct.task.mjs import colors from 'ansi-colors' import log from 'fancy-log' import { existsSync, rmSync } from 'fs' import { glob } from 'glob' import { basename, dirname, extname, join, normalize } from 'path' import { rollup } from 'rollup' import { getTaskConfigurationFor, logLoadingTask, packageSourcesDirectory, packageTestsBundlesDirectory } from '../../_utils.mjs' logLoadingTask( import.meta.filename ) const { red, green, magenta, } = colors /** * @description In view to detect bundling side effects this task will * create intermediary file for each individual export from this package * and then create rollup config for each of them and bundle * Todo: Check for different target env like next task below this one */ const checkBundlingFromEsmFilesDirectTask = async ( done ) =&gt; { const outputDir = join( packageTestsBundlesDirectory, 'from_files_direct' ) if ( existsSync( outputDir ) ) { log( 'Clean up', magenta( outputDir ) ) rmSync( outputDir, { recursive: true } ) } const configuration = await getTaskConfigurationFor( import.meta.filename ) // Get source files to process const pattern = join( packageSourcesDirectory, '**' ) const sourceFiles = glob.sync( pattern ) .map( filePath =&gt; normalize( filePath ) ) .filter( filePath =&gt; { const fileName = basename( filePath ) const isJsFile = fileName.endsWith( '.js' ) const isNotPrivateFile = !fileName.startsWith( '_' ) const isNotIgnoredFile = !configuration.ignoredFiles.includes( fileName ) return isJsFile &amp;&amp; isNotPrivateFile &amp;&amp; isNotIgnoredFile } ) for ( let sourceFile of sourceFiles ) { const specificFilePath = sourceFile.replace( packageSourcesDirectory, '' ) const specificDir = dirname( specificFilePath ) const fileName = basename( sourceFile, extname( sourceFile ) ) const bundleFileName = `${ fileName }.bundle.js` const bundleFilePath = join( outputDir, specificDir, bundleFileName ) configuration.buildOptions.input = sourceFile configuration.buildOptions.output.file = bundleFilePath try { log( 'Bundling', green( configuration.buildOptions.output.file ) ) const bundle = await rollup( configuration.buildOptions ) await bundle.generate( configuration.buildOptions.output ) await bundle.write( configuration.buildOptions.output ) } catch ( error ) { log( red( error.message ) ) } } done() } checkBundlingFromEsmFilesDirectTask.displayName = basename( import.meta.filename, '.task.mjs' ) checkBundlingFromEsmFilesDirectTask.description = 'In view to detect bundling side effects this task will create intermediary file for each individual export from this package and then create rollup config for each of them and bundle' checkBundlingFromEsmFilesDirectTask.flags = null export { checkBundlingFromEsmFilesDirectTask } × Search results Close "},"tests_bundlings_check-bundling.task.mjs.html":{"id":"tests_bundlings_check-bundling.task.mjs.html","title":"Source: tests/bundlings/check-bundling.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/bundlings/check-bundling.task.mjs import { series } from 'gulp' import { basename } from 'node:path' import { logLoadingTask } from '../../_utils.mjs' import { checkBundlingFromEsmBuildImportTask } from './check-bundling-from-esm-build-import.task.mjs' import { checkBundlingFromEsmFilesDirectTask } from './check-bundling-from-esm-files-direct.task.mjs' import { checkBundlingFromEsmFilesImportTask } from './check-bundling-from-esm-files-import.task.mjs' logLoadingTask( import.meta.filename ) /** * @description In view to detect bundling side effects this task will * create intermediary file for each individual export from this package * and then create rollup config for each of them and bundle * Todo: Check for different targets env like next task below this one */ const checkBundlingTask = series( checkBundlingFromEsmFilesImportTask, checkBundlingFromEsmBuildImportTask, checkBundlingFromEsmFilesDirectTask ) checkBundlingTask.displayName = basename( import.meta.filename, '.task.mjs' ) checkBundlingTask.description = 'In view to detect bundling side effects this task will create intermediary file for each individual export and then try to bundle them.' export { checkBundlingTask } × Search results Close "},"tests_benchmarks_compute-benchmarks.task.mjs.html":{"id":"tests_benchmarks_compute-benchmarks.task.mjs.html","title":"Source: tests/benchmarks/compute-benchmarks.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/benchmarks/compute-benchmarks.task.mjs import colors from 'ansi-colors' import childProcess from 'child_process' import log from 'fancy-log' import { glob } from 'glob' import { basename, dirname, extname, join, normalize, relative } from 'path' import { createDirectoryIfNotExist, createFile, getTaskConfigurationFor, logLoadingTask, packageName, packageNodeModulesDirectory, packageSourcesDirectory, packageTestsBenchmarksDirectory, packageTestsDirectory } from '../../_utils.mjs' logLoadingTask( import.meta.filename ) const { red, yellow, } = colors /** * @description Will generate benchmarks files from source code against provided alternatives */ const computeBenchmarksTask = async ( done ) =&gt; { createDirectoryIfNotExist( packageTestsBenchmarksDirectory ) // Get task configuration const filePathsToIgnore = await getTaskConfigurationFor( import.meta.filename ) // Get source files to process const pattern = join( packageSourcesDirectory, '**' ) const sourceFiles = glob.sync( pattern ) .map( filePath =&gt; normalize( filePath ) ) .filter( filePath =&gt; { const fileName = basename( filePath ) const isJsFile = fileName.endsWith( '.js' ) const isNotPrivateFile = !fileName.startsWith( '_' ) const isNotIgnoredFile = !filePathsToIgnore.includes( fileName ) return isJsFile &amp;&amp; isNotPrivateFile &amp;&amp; isNotIgnoredFile } ) const benchRootImports = [] for ( let sourceFile of sourceFiles ) { const specificFilePath = sourceFile.replace( packageSourcesDirectory, '' ) const specificDir = dirname( specificFilePath ) const fileName = basename( sourceFile, extname( sourceFile ) ) const benchFileName = `${ fileName }.bench.js` const benchDirPath = join( packageTestsBenchmarksDirectory, specificDir ) const benchFilePath = join( benchDirPath, benchFileName ) const nsName = `${ fileName }Namespace` const importDirPath = relative( benchDirPath, packageSourcesDirectory ) const importFilePath = join( importDirPath, specificFilePath ).replace( /\\\\/g, '/' ) try { const jsdocPath = join( packageNodeModulesDirectory, '/jsdoc/jsdoc.js' ) const jsdocOutput = childProcess.execFileSync( 'node', [ jsdocPath, '-X', sourceFile ] ).toString() const classNames = [] const usedLongnames = [] const jsonData = JSON.parse( jsdocOutput ).filter( data =&gt; { const longName = data.longname const kind = data.kind if ( kind !== 'function' ) { if ( kind === 'class' &amp;&amp; !classNames.includes( longName ) ) { classNames.push( longName ) } return false } // We don't care that data bloc have comment they are unused to generate benchmarks // const undocumented = data.undocumented // if ( undocumented ) { // return false // } const scope = data.scope if ( ![ 'global', 'static' ].includes( scope ) ) { return false } if ( longName.includes( ' ' ) || longName.includes( '~' ) || usedLongnames.includes( longName ) ) { return false } for ( let className of classNames ) { if ( longName.includes( className ) ) { return false } } usedLongnames.push( longName ) return true } ) if ( jsonData.length === 0 ) { log( 'Ignoring', yellow( `${ sourceFile }, no usable exports found` ) ) continue } // Compute benchmark suites by grouping logically function by name[_x] const suiteGroups = {} for ( let docData of jsonData ) { try { const functionName = docData.name const nameSplits = functionName.split( '_' ) const rootName = nameSplits[ 0 ] if ( !( rootName in suiteGroups ) ) { suiteGroups[ rootName ] = [] } suiteGroups[ rootName ].push( functionName ) } catch ( error ) { log( red( error.message ) ) } } // Generate suites let benchSuites = '' const suitesToExports = [] for ( let suiteGroupName in suiteGroups ) { suitesToExports.push( `${ suiteGroupName }Suite` ) benchSuites += `const ${ suiteGroupName }Suite = Benchmark.Suite( '${ nsName }.${ suiteGroupName }', Testing.createSuiteOptions() )` + '\\n' for ( let suiteGroupValue of suiteGroups[ suiteGroupName ] ) { benchSuites += ` .add( '${ suiteGroupValue }()', Testing.iterateOverDataMap( ${ nsName }.${ suiteGroupValue } ), Testing.createBenchmarkOptions() )` + '\\n' } benchSuites += '\\n' } // compute relative level to get import wrappers const wrapperDirPath = relative( benchDirPath, packageTestsDirectory ) const importBenchmarkFilePath = join( wrapperDirPath, 'import.benchmarks.js' ) const importTestingFilePath = join( wrapperDirPath, 'import.testing.js' ) const template = '' + `import * as ${ nsName } from '${ importFilePath }'` + '\\n' + `import { getBenchmarkPackage } from '${ importBenchmarkFilePath }'` + '\\n' + `import { getTestingPackage } from '${ importTestingFilePath }'` + '\\n' + '\\n' + `const Benchmark = await getBenchmarkPackage()` + '\\n' + `const Testing = await getTestingPackage()` + '\\n' + '\\n' + `${ benchSuites }` + // '\\n' + `export { ${ suitesToExports } }` + '\\n' + '\\n' const importBenchFilePath = relative( packageTestsBenchmarksDirectory, benchFilePath ).replace( /\\\\/g, '/' ) benchRootImports.push( { path: importBenchFilePath, exports: suitesToExports } ) createDirectoryIfNotExist( benchDirPath ) createFile( benchFilePath, template ) } catch ( error ) { log( red( error.message ) ) } } let templateImports = '' let suites = [] for ( let i = 0 ; i &lt; benchRootImports.length ; i++ ) { const currentBench = benchRootImports[ i ] const namedExports = currentBench.exports const imports = namedExports.join( ', ' ) suites.push( ...namedExports ) templateImports += `import {${ imports }} from './${ currentBench.path }'` + '\\n' } // Use a fallback in case no benches were found at all if ( benchRootImports.length === 0 ) { log( 'Warning ', yellow( 'No usable exports found, generate default file to avoid frontend breakage.' ) ) const defaultBenchesDir = join( packageTestsBenchmarksDirectory, 'default' ) const defaultBenchesPath = join( defaultBenchesDir, 'default.bench.js' ) createDirectoryIfNotExist( defaultBenchesDir ) createFile( defaultBenchesPath, '// Avoid web test runner crash on empty benches' ) } const benchesTemplate = '' + `${ templateImports }` + '\\n' + 'const suites = [' + '\\n' + `${ suites.map( suite =&gt; `\\t${ suite }` ).join( ',\\n' ) }` + '\\n' + ']' + '\\n' + '\\n' + `for ( const suite of suites ) {` + '\\n' + `\\tsuite.run()` + '\\n' + `}` + '\\n' const benchesFilePath = join( packageTestsBenchmarksDirectory, `${ packageName }.benchmarks.js` ) createFile( benchesFilePath, benchesTemplate ) done() } computeBenchmarksTask.displayName = basename( import.meta.filename, '.task.mjs' ) computeBenchmarksTask.description = 'Will generate benchmarks files from source code against provided alternatives.' computeBenchmarksTask.flags = null export { computeBenchmarksTask } × Search results Close "},"tests_units_compute-unit-tests.task.mjs.html":{"id":"tests_units_compute-unit-tests.task.mjs.html","title":"Source: tests/units/compute-unit-tests.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/units/compute-unit-tests.task.mjs import colors from 'ansi-colors' import childProcess from 'child_process' import log from 'fancy-log' import { glob } from 'glob' import { isNotEmptyArray } from 'itee-validators' import { basename, dirname, extname, join, normalize, relative } from 'path' import { createDirectoryIfNotExist, createFile, getPrettyPackageName, getTaskConfigurationFor, Indenter, logLoadingTask, packageName, packageNodeModulesDirectory, packageSourcesDirectory, packageTestsUnitsDirectory } from '../../_utils.mjs' logLoadingTask( import.meta.filename ) const { red, yellow, } = colors /** * @description Will generate unit test files from source code using type inference from comments */ const computeUnitTestsTask = async ( done ) =&gt; { createDirectoryIfNotExist( packageTestsUnitsDirectory ) // Get task configuration const filePathsToIgnore = await getTaskConfigurationFor( import.meta.filename ) // Get source files to process const pattern = join( packageSourcesDirectory, '**' ) const sourceFiles = glob.sync( pattern ) .map( filePath =&gt; normalize( filePath ) ) .filter( filePath =&gt; { const fileName = basename( filePath ) const isJsFile = fileName.endsWith( '.js' ) const isNotPrivateFile = !fileName.startsWith( '_' ) const isNotIgnoredFile = !filePathsToIgnore.includes( fileName ) return isJsFile &amp;&amp; isNotPrivateFile &amp;&amp; isNotIgnoredFile } ) const unitsImportMap = [] for ( let sourceFile of sourceFiles ) { const specificFilePath = sourceFile.replace( packageSourcesDirectory, '' ) const specificDir = dirname( specificFilePath ) const fileName = basename( sourceFile, extname( sourceFile ) ) const unitFileName = `${ fileName }.unit.mjs` const unitDirPath = join( packageTestsUnitsDirectory, specificDir ) const unitFilePath = join( unitDirPath, unitFileName ) const nsName = `${ fileName }Namespace` const unitName = `${ fileName }Units` const importDirPath = relative( unitDirPath, packageSourcesDirectory ) const importFilePath = join( importDirPath, specificFilePath ).replace( /\\\\/g, '/' ) try { const jsdocPath = join( packageNodeModulesDirectory, '/jsdoc/jsdoc.js' ) const jsdocOutput = childProcess.execFileSync( 'node', [ jsdocPath, '-X', sourceFile ] ).toString() const classNames = [] const usedLongnames = [] const jsonData = JSON.parse( jsdocOutput ).filter( data =&gt; { const longName = data.longname const kind = data.kind if ( kind !== 'function' ) { if ( kind === 'class' &amp;&amp; !classNames.includes( longName ) ) { classNames.push( longName ) } return false } const undocumented = data.undocumented if ( undocumented ) { return false } const scope = data.scope if ( ![ 'global', 'static' ].includes( scope ) ) { return false } if ( longName.includes( ' ' ) || longName.includes( '~' ) || usedLongnames.includes( longName ) ) { return false } for ( let className of classNames ) { if ( longName.includes( className ) ) { return false } } usedLongnames.push( longName ) return true } ) if ( jsonData.length === 0 ) { log( 'Ignoring', yellow( `${ sourceFile }, no usable exports found` ) ) continue } let describes = '' const { I, I_, I__, I___, } = new Indenter( '\\t', 3 ) for ( let docData of jsonData ) { try { //check input parameters and types const docParameters = docData.params || [] const parameters = [] for ( let pIndex = 0 ; pIndex &lt; docParameters.length ; pIndex++ ) { const param = docParameters[ pIndex ] let paramName = param.name if ( !paramName ) { paramName = `param${ pIndex }` log( yellow( `Missing parameter name for [${ docData.longname }]. Defaulting to [${ paramName }]` ) ) } const paramType = param.type if ( !paramType ) { throw new ReferenceError( `Missing parameter type. Unable to create unit test for [${ docData.longname }] !` ) } const parameter = { name: paramName, types: [] } const paramTypeNames = paramType.names for ( let type of paramTypeNames ) { parameter.types.push( type ) } parameters.push( parameter ) } // Check returns types const docReturns = docData.returns || [] const returns = [] for ( let docReturn of docReturns ) { const returnType = docReturn.type if ( !returnType ) { throw new ReferenceError( `Missing return type for [${ docData.longname }]. Ignore current target !` ) } returns.push( ...returnType.names ) } // Todo check throws // Get user define rules // const rules = [] // Infer basic rules const baseIndent = 2 let its = '' if ( parameters.length === 0 ) { if ( returns.length === 0 ) { const result = `${ I._( baseIndent + 1 ) }const result = ${ nsName }.${ docData.name }()` + '\\n' const expect = `${ I._( baseIndent + 1 ) }expect(result).to.be.a('undefined')` + '\\n' its += '' + `${ I._( baseIndent ) }it( 'should return undefined value on call', async function () {` + '\\n' + '\\n' + `${ result }` + `${ expect }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } else if ( returns.length === 1 ) { const firstReturnType = returns[ 0 ] const lowerName = firstReturnType.toLowerCase() const result = `${ I._( baseIndent + 1 ) }const result = ${ nsName }.${ docData.name }()` + '\\n' let expect = '' if ( lowerName.startsWith( 'array' ) ) { //todo array of... expect += `${ I._( baseIndent + 1 ) }expect(result).to.be.a('array')` + '\\n' } else { expect += `${ I._( baseIndent + 1 ) }expect(result).to.be.a('${ lowerName }')` + '\\n' } its += '' + `${ I._( baseIndent ) }it( 'should return value of type ${ lowerName }', async function() {` + '\\n' + '\\n' + `${ result }` + `${ expect }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } else { const result = `${ I._( baseIndent + 1 ) }const result = ${ nsName }.${ docData.name }()` + '\\n' let returnTypesLabel = [] let oneOf = [] for ( let returnType of returns ) { const lowerName = returnType.toLowerCase() returnTypesLabel.push( lowerName ) if ( lowerName.startsWith( 'array' ) ) { //todo array of... oneOf.push( 'array' ) } else { oneOf.push( `'${ lowerName }'` ) } } const underlyingType = `${ I._( baseIndent + 1 ) }const resultType = (result === null) ? 'null' : typeof result` + '\\n' const expect = `${ I._( baseIndent + 1 ) }expect(resultType).to.be.oneOf([${ oneOf.join( ',' ) }])` + '\\n' its += '' + `${ I._( baseIndent ) }it( 'should return value where type is ${ returnTypesLabel.join( ' or ' ) }', async function() {` + '\\n' + '\\n' + `${ result }` + `${ underlyingType }` + `${ expect }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } } else { if ( returns.length === 0 ) { let itDeclaration = [] let index = 0 let indent = baseIndent + 1 let localIndent = indent let dataSets = '' let forLoopOpens = '' let forLoopCloses = '' let args = [] for ( let parameter of parameters ) { const parameterType = parameter.types[ 0 ] itDeclaration.push( `${ parameter.name } is of type ${ parameterType }` ) dataSets += `${ I._( indent ) }const dataSet${ index } = _dataMap[ '${ parameterType }s' ]` + '\\n' // dataSets += `${ I._( indent ) }const dataSet${ index } = this._dataMap[ '${ parameterType }s' ]` + '\\n' forLoopOpens += '' + '\\n' + `${ I._( localIndent ) }for ( let key${ index } in dataSet${ index } ) {` + '\\n' + `${ I._( localIndent + 1 ) }const dataSetValue${ index } = dataSet${ index }[ key${ index } ]` + '\\n' args.push( `dataSetValue${ index }` ) forLoopCloses = `${ I._( localIndent ) }}` + '\\n' + `${ forLoopCloses }` index++ localIndent++ } const result = `${ I._( localIndent ) }const result = ${ nsName }.${ docData.name }( ${ args.join( ', ' ) } )` + '\\n' const expect = `${ I._( localIndent ) }expect(result).to.be.a('undefined')` + '\\n' const param = '' + `${ dataSets }` + `${ forLoopOpens }` + `${ result }` + `${ expect }` + `${ forLoopCloses }` its += '' + `${ I._( baseIndent ) }it( 'should return undefined value when ${ itDeclaration.join( ' and ' ) }', async function() {` + '\\n' + '\\n' + `${ param }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } else if ( returns.length === 1 ) { const firstReturnType = returns[ 0 ] const lowerName = firstReturnType.toLowerCase() let itDeclaration = [] let index = 0 let indent = baseIndent + 1 let localIndent = indent let dataSets = '' let forLoopOpens = '' let forLoopCloses = '' let args = [] for ( let parameter of parameters ) { const parameterType = parameter.types[ 0 ] const isAnyType = ( parameterType === '*' || parameterType.toLowerCase() === 'any' ) const declaration = ( isAnyType ) ? `${ parameter.name } is of any type` : `${ parameter.name } is of type ${ parameterType }` itDeclaration.push( declaration ) if ( isAnyType ) { dataSets += `${ I._( indent ) }const dataMap${ index } = _dataMap` + '\\n' + // dataSets += `${ I._( indent ) }const dataMap${ index } = this._dataMap` + '\\n' + `${ I._( localIndent ) }for ( let dataSetKey${ index } in dataMap${ index } ) {` + '\\n' localIndent++ dataSets += `${ I._( indent + 1 ) }const dataSet${ index } = dataMap${ index }[ dataSetKey${ index } ]` + '\\n' forLoopOpens += '' + '\\n' + `${ I._( localIndent ) }for ( let key${ index } in dataSet${ index } ) {` + '\\n' + `${ I._( localIndent + 1 ) }const dataSetValue${ index } = dataSet${ index }[ key${ index } ]` + '\\n' args.push( `dataSetValue${ index }` ) forLoopCloses = `${ I._( localIndent ) }}` + '\\n' + `${ I._( localIndent - 1 ) }}` + '\\n' + `${ forLoopCloses }` } else { dataSets += `${ I._( indent ) }const dataSet${ index } = _dataMap[ '${ parameterType }s' ]` + '\\n' // dataSets += `${ I._( indent ) }const dataSet${ index } = this._dataMap[ '${ parameterType }s' ]` + '\\n' forLoopOpens += '' + '\\n' + `${ I._( localIndent ) }for ( let key${ index } in dataSet${ index } ) {` + '\\n' + `${ I._( localIndent + 1 ) }const dataSetValue${ index } = dataSet${ index }[ key${ index } ]` + '\\n' args.push( `dataSetValue${ index }` ) forLoopCloses = `${ I._( localIndent ) }}` + '\\n' + `${ forLoopCloses }` } index++ localIndent++ } const result = `${ I._( localIndent ) }const result = ${ nsName }.${ docData.name }( ${ args.join( ', ' ) } )` + '\\n' let expect = '' if ( lowerName.startsWith( 'array' ) ) { expect = `${ I._( localIndent ) }expect(result).to.be.a('array')` + '\\n' //todo array of... } else { expect = `${ I._( localIndent ) }expect(result).to.be.a('${ lowerName }')` + '\\n' } const param = '' + `${ dataSets }` + `${ forLoopOpens }` + `${ result }` + `${ expect }` + `${ forLoopCloses }` its += '' + `${ I._( baseIndent ) }it( 'should return value of type ${ lowerName } when ${ itDeclaration.join( ' and ' ) }', async function() {` + '\\n' + '\\n' + `${ param }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } else { let itDeclaration = [] let index = 0 let indent = baseIndent + 1 let localIndent = indent let dataSets = '' let forLoopOpens = '' let forLoopCloses = '' let args = [] for ( let parameter of parameters ) { const parameterType = parameter.types[ 0 ] itDeclaration.push( `${ parameter.name } is of type ${ parameterType }` ) dataSets += `${ I._( localIndent ) }const dataSet${ index } = _dataMap[ '${ parameterType }s' ]` + '\\n' // dataSets += `${ I._( indent ) }const dataSet${ index } = this._dataMap[ '${ parameterType }s' ]` + '\\n' forLoopOpens += '' + '\\n' + `${ I._( localIndent ) }for ( let key${ index } in dataSet${ index } ) {` + '\\n' + `${ I._( localIndent + 1 ) }const dataSetValue${ index } = dataSet${ index }[ key${ index } ]` + '\\n' args.push( `dataSetValue${ index }` ) forLoopCloses = `${ I._( localIndent ) }}` + '\\n' + `${ forLoopCloses }` index++ localIndent++ } const result = `${ I._( localIndent + 1 ) }const result = ${ nsName }.${ docData.name }( ${ args.join( ', ' ) } )` + '\\n' let returnTypesLabel = [] let oneOf = [] for ( let returnType of returns ) { const lowerName = returnType.toLowerCase() returnTypesLabel.push( lowerName ) if ( lowerName.startsWith( 'array' ) ) { //todo array of... oneOf.push( 'array' ) } else { oneOf.push( `'${ lowerName }'` ) } } const underlyingType = `${ I._( localIndent + 1 ) }const resultType = (result === null) ? 'null' : typeof result` + '\\n' const expect = `${ I._( localIndent + 1 ) }expect(resultType).to.be.oneOf([${ oneOf.join( ',' ) }])` + '\\n' const param = '' + `${ dataSets }` + `${ forLoopOpens }` + `${ result }` + `${ underlyingType }` + `${ expect }` + `${ forLoopCloses }` its += '' + `${ I._( baseIndent ) }it( 'should return value of type ${ returnTypesLabel.join( ' or ' ) } when ${ itDeclaration.join( ' and ' ) }', async function() {` + '\\n' + '\\n' + `${ param }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } } describes += '' + `${ I_ }describe( '${ docData.name }()', function () {` + '\\n' + '\\n' + `${ I__ }it( 'should be bundlable', async function () {` + '\\n' + '\\n' + `${ I___ }expect(${ nsName }.${ docData.name }).to.exist` + '\\n' + '\\n' + `${ I__ }} )` + '\\n' + '\\n' + `${ its }` + '\\n' + `${ I_ }} )` + '\\n' + '\\n' } catch ( error ) { log( red( error.message ) ) } } const template = '' + `import { expect } from 'chai'` + '\\n' + `import { Testing } from 'itee-utils/sources/testings/benchmarks.js'` + '\\n' + `import * as ${ nsName } from '${ importFilePath }'` + '\\n' + '\\n' + `describe( '${ unitName }', function () {` + '\\n' + '\\n' + `${ I_ }let _dataMap` + '\\n' + `${ I_ }before( function() {` + '\\n' + `${ I__ }_dataMap = Testing.createDataMap()` + '\\n' + `${ I_ }} )` + '\\n' + '\\n' + `${ describes }` + '' + `} )` + '\\n' const importUnitFilePath = relative( packageTestsUnitsDirectory, unitFilePath ) unitsImportMap.push( { exportName: unitName, path: importUnitFilePath.replace( /\\\\/g, '/' ) } ) createDirectoryIfNotExist( unitDirPath ) createFile( unitFilePath, template ) } catch ( error ) { log( red( error.message ) ) } } // If some tests to import generate global units file let unitsTemplate if ( isNotEmptyArray( unitsImportMap ) ) { let computedImports = [] for ( let entry of unitsImportMap ) { // computedImports.push(`import { ${ entry.exportName } } from './${ entry.path }'`) computedImports.push( `export * from './${ entry.path }'` ) } unitsTemplate = computedImports.join( '\\n' ) } else { log( 'Warning ', yellow( 'No tests were generated. Create fallback global root import file.' ) ) const defaultUnitsDir = join( packageTestsUnitsDirectory, 'default' ) const defaultUnitsPath = join( defaultUnitsDir, 'default.unit.mjs' ) createDirectoryIfNotExist( defaultUnitsDir ) createFile( defaultUnitsPath, '// Avoid web test runner crash on empty benches' ) const prettyPackageName = getPrettyPackageName( '#' ) unitsTemplate = `describe( '${ prettyPackageName }', () =&gt; {} )` + '\\n' } const unitsFilePath = join( packageTestsUnitsDirectory, `${ packageName }.units.mjs` ) createFile( unitsFilePath, unitsTemplate ) done() } computeUnitTestsTask.displayName = basename( import.meta.filename, '.task.mjs' ) computeUnitTestsTask.description = 'Will generate unit test files from source code using type inference from comments' computeUnitTestsTask.flags = null export { computeUnitTestsTask } × Search results Close "},"-_utils.mjs.html":{"id":"-_utils.mjs.html","title":"Source: _utils.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: _utils.mjs import commonjs from '@rollup/plugin-commonjs' import nodeResolve from '@rollup/plugin-node-resolve' import terser from '@rollup/plugin-terser' import colors from 'ansi-colors' import childProcess from 'child_process' import log from 'fancy-log' import figlet from 'figlet' import { glob } from 'glob' import { parallel, series } from 'gulp' import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs' import { basename, dirname, extname, join, normalize, relative, } from 'node:path' import { fileURLToPath } from 'node:url' import replace from 'rollup-plugin-re' const { red, green, yellow, blue, magenta, cyan } = colors /// Debugging const isDebugging = ( process.env.RUNNER_DEBUG &amp;&amp; process.env.RUNNER_DEBUG === '1' ) /// Package paths and data function _getPackageRootDirectory() { let __dirname if ( import.meta.dirname ) { __dirname = import.meta.dirname } else if ( import.meta.filename ) { __dirname = dirname( import.meta.filename ) } else if ( import.meta.url ) { const __filename = fileURLToPath( import.meta.url ) __dirname = dirname( __filename ) } else { throw new Error( 'Unable to retrieve module dirname.' ) } return join( __dirname, '..' ) } const iteePackageRootDirectory = _getPackageRootDirectory() const iteePackageJsonPath = join( iteePackageRootDirectory, 'package.json' ) const iteePackageConfigurationsDirectory = join( iteePackageRootDirectory, 'configs' ) const iteePackageNodeModulesDirectory = join( iteePackageRootDirectory, 'node_modules' ) const iteePackageSourcesDirectory = join( iteePackageRootDirectory, 'sources' ) const packageRootDirectory = iteePackageRootDirectory.includes( 'node_modules' ) ? join( iteePackageRootDirectory, '../../../' ) : iteePackageRootDirectory const packageTasksDirectory = join( packageRootDirectory, '.tasks' ) const packageTasksConfigurationsDirectory = join( packageTasksDirectory, 'configs' ) const packageNodeModulesDirectory = join( packageRootDirectory, 'node_modules' ) const packageBuildsDirectory = join( packageRootDirectory, 'builds' ) const packageSourcesDirectory = join( packageRootDirectory, 'sources' ) const packageSourcesBackendDirectory = join( packageSourcesDirectory, 'backend' ) const packageSourcesCommonDirectory = join( packageSourcesDirectory, 'common' ) const packageSourcesFrontendDirectory = join( packageSourcesDirectory, 'frontend' ) const packageTestsDirectory = join( packageRootDirectory, 'tests' ) const packageTestsBenchmarksDirectory = join( packageTestsDirectory, 'benchmarks' ) const packageTestsBundlesDirectory = join( packageTestsDirectory, 'bundles' ) const packageTestsUnitsDirectory = join( packageTestsDirectory, 'units' ) const packageDocsDirectory = join( packageRootDirectory, 'docs' ) const packageTutorialsDirectory = join( packageRootDirectory, 'tutorials' ) const packageJsonPath = join( packageRootDirectory, 'package.json' ) /// const packageJson = getJsonFrom( packageJsonPath ) const packageName = packageJson.name const packageVersion = packageJson.version const packageDescription = packageJson.description const packageAuthor = packageJson.author const packageLicense = packageJson.license function getPrettyPackageName( separator = ' ' ) { let prettyPackageName = '' const nameSplits = packageName.split( '-' ) for ( const nameSplit of nameSplits ) { prettyPackageName += nameSplit.charAt( 0 ).toUpperCase() + nameSplit.slice( 1 ) + separator } prettyPackageName = prettyPackageName.slice( 0, -1 ) return prettyPackageName } function getPrettyPackageVersion() { return 'v' + packageVersion } function getPrettyNodeVersion() { let nodeVersion = 'vX.x.ₓ' try { nodeVersion = childProcess.execFileSync( 'node', [ '--version' ] ) .toString() .replace( /(\\r\\n|\\n|\\r)/gm, '' ) } catch ( e ) { log( red( e ) ) if ( e.message.includes( 'ENOENT' ) ) { nodeVersion += yellow( ' Not seems to be accessible from the path environment.' ) } } return ' node: ' + nodeVersion } function getPrettyNpmVersion() { let npmVersion = 'X.x.ₓ' try { npmVersion = childProcess.execFileSync( 'npm', [ '--version' ] ) .toString() .replace( /(\\r\\n|\\n|\\r)/gm, '' ) } catch ( e ) { log( red( e ) ) if ( e.message.includes( 'ENOENT' ) ) { npmVersion += yellow( ' Not seems to be accessible from the path environment.' ) } } return ' npm: v' + npmVersion } /// File system Management function createDirectoryIfNotExist( directoryPath ) { if ( !existsSync( directoryPath ) ) { log( 'Creating', green( directoryPath ) ) mkdirSync( directoryPath, { recursive: true } ) } } function getJsonFrom( path ) { const buffer = readFileSync( path ) return JSON.parse( buffer.toString() ) } function createFile( filePath, fileContent ) { log( 'Creating', green( filePath ) ) writeFileSync( filePath, fileContent ) } function getFilesFrom( globPattern, filter = ( any ) =&gt; true ) { return glob.sync( globPattern ) .map( filePath =&gt; normalize( filePath ) ) .filter( filter ) } /// Task Management async function getTasksFrom( taskFiles = [] ) { const tasks = [] for ( const taskFile of taskFiles ) { const relativeTaskFile = relative( packageRootDirectory, taskFile ) try { const module = await import(taskFile) const exportStrings = [] for ( const moduleKey in module ) { const task = module[ moduleKey ] tasks.push( task ) const name = task.name ?? null const displayName = task.displayName ?? null const fullName = ( moduleKey !== name ) ? `${ blue( moduleKey ) }( ${ magenta( name ) } )` : `${ blue( name ) }` const exportAs = ( displayName ) ? ` as ${ cyan( displayName ) }` : '' const exportString = fullName + exportAs exportStrings.push( exportString ) } //log( 'Process ', green( relativeTaskFile ), `with task${ ( exportStrings.length &gt; 1 ) ? 's' : '' }`, exportStrings.join( ', ' ) ) } catch ( error ) { log( 'Error ', red( relativeTaskFile ), error.message ) } } return tasks } async function serializeTasksFrom( taskFiles = [] ) { const tasks = await getTasksFrom( taskFiles ) return series( ...tasks ) } async function parallelizeTasksFrom( taskFiles = [] ) { const tasks = await getTasksFrom( taskFiles ) return parallel( ...tasks ) } /// Task configuration management function getTaskConfigurationPathFor( filename ) { // Get relative path of the task between internal or user defined let relativeTaskPath = filename.includes( iteePackageSourcesDirectory ) ? relative( iteePackageSourcesDirectory, filename ) : relative( packageTasksDirectory, filename ) // Generate all possible config file path depending on file extension and default or user defined const terminalExtension = extname( relativeTaskPath ) const searchValue = relativeTaskPath.includes( '.task.' ) ? `.task${ terminalExtension }` : terminalExtension const replaceValues = [ '.conf.json', '.conf.js', '.conf.cjs', '.conf.mjs', ] const packageConfigurationPaths = [] const defaultConfigurationPaths = [] for ( const replaceValue of replaceValues ) { const configurationLocation = relativeTaskPath.replace( searchValue, replaceValue ) const packageConfigurationPath = join( packageTasksConfigurationsDirectory, configurationLocation ) const defaultConfigurationPath = join( iteePackageConfigurationsDirectory, configurationLocation ) packageConfigurationPaths.push( packageConfigurationPath ) defaultConfigurationPaths.push( defaultConfigurationPath ) } // Take care of the configuration search order (package first then default !) const configurationPaths = [ ...packageConfigurationPaths, ...defaultConfigurationPaths ] let configurationPath = undefined // Looking for existing configuration file for ( const packageConfigurationPath of configurationPaths ) { if ( existsSync( packageConfigurationPath ) ) { configurationPath = packageConfigurationPath break } } // Else throw an error if ( !configurationPath ) { throw new Error( `Unable to find configuration in package configuration paths ${ configurationPaths.join( ', ' ) }.` ) } return configurationPath } async function getTaskConfigurationFor( filename ) { const configurationFilePath = getTaskConfigurationPathFor( filename ) log( `Loading configuration from ${ cyan( configurationFilePath ) }` ) let configuration = null try { if ( extname( configurationFilePath ) === '.json' ) { configuration = getJsonFrom( configurationFilePath ) } else { const moduleData = await import( configurationFilePath ) configuration = moduleData.default } } catch ( e ) { log( red( e ) ) } return configuration } /// Build management function getPrettyFormatForBanner( format ) { let prettyFormat = '' switch ( format ) { case 'cjs': prettyFormat = 'CommonJs' break case 'esm': prettyFormat = 'EsModule' break case 'iife': prettyFormat = 'Standalone' break case 'umd': prettyFormat = 'Universal' break default: throw new RangeError( `Invalid switch parameter: ${ format }` ) } return prettyFormat } function convertBannerIntoComment( banner ) { let bannerCommented = '/**\\n' bannerCommented += ' * ' bannerCommented += banner.replaceAll( '\\n', '\\n * ' ) bannerCommented += '\\n' bannerCommented += ` * @desc ${ packageDescription }\\n` bannerCommented += ' * @author [Tristan Valcke]{@link https://github.com/Itee}\\n' bannerCommented += ' * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}\\n' bannerCommented += ' * \\n' bannerCommented += ' */' return bannerCommented } function computeBannerFor( format ) { const packageName = getPrettyPackageName( '.' ) const packageVersion = getPrettyPackageVersion() const prettyFormat = getPrettyFormatForBanner( format ) const figText = figlet.textSync( `${ packageName } ${ packageVersion } - ${ prettyFormat }`, { font: 'Tmplr', horizontalLayout: 'default', verticalLayout: 'default', whitespaceBreak: true, } ) return convertBannerIntoComment( figText ) } function computeIntroFor( requestPackages ) { return '' } function getOutputFileExtensionBasedOnFileFormat( format ) { let extension if ( format === 'cjs' ) { extension = 'cjs' } else if ( format === 'esm' ) { extension = 'mjs' } else { extension = 'js' } return extension } /** * Will create an appropriate configuration object for rollup, related to the given arguments. * * @generator * @param options * @return {Array.&lt;json&gt;} An array of rollup configuration */ function createRollupConfigs( options = undefined ) { const _options = options ? options : { input: join( packageSourcesDirectory, `${ packageName }.js` ), output: packageBuildsDirectory, formats: [ 'esm', 'cjs', 'iife' ], envs: [ 'dev', 'prod' ], treeshake: true } const { input, output, formats, envs, treeshake } = _options const name = getPrettyPackageName( '.' ) const fileName = basename( input, '.js' ) const configs = [] for ( let formatIndex = 0, numberOfFormats = formats.length ; formatIndex &lt; numberOfFormats ; ++formatIndex ) { for ( let envIndex = 0, numberOfEnvs = envs.length ; envIndex &lt; numberOfEnvs ; envIndex++ ) { const env = envs[ envIndex ] const isProd = ( env.includes( 'prod' ) ) const format = formats[ formatIndex ] const extension = getOutputFileExtensionBasedOnFileFormat( format ) const outputPath = ( isProd ) ? join( output, `${ fileName }.min.${ extension }` ) : join( output, `${ fileName }.${ extension }` ) configs.push( { input: input, external: ( format === 'cjs' ) ? [ 'fs' ] : [], plugins: [ replace( { defines: { IS_REMOVE_ON_BUILD: false, IS_BACKEND_SPECIFIC: ( format === 'cjs' ) } } ), commonjs( { include: 'node_modules/**' } ), nodeResolve( { preferBuiltins: true } ), isProd &amp;&amp; terser() ], onwarn: ( { loc, frame, message } ) =&gt; { // Ignore some errors if ( message.includes( 'Circular dependency' ) ) { return } if ( message.includes( 'plugin uglify is deprecated' ) ) { return } if ( loc ) { process.stderr.write( `/!\\\\ ${ loc.file } (${ loc.line }:${ loc.column }) ${ frame } ${ message }\\n` ) } else { process.stderr.write( `/!\\\\ ${ message }\\n` ) } }, treeshake: treeshake, output: { // core options file: outputPath, format: format, name: name, globals: {}, // advanced options paths: {}, banner: ( isProd ) ? '' : computeBannerFor( format ), footer: '', intro: ( !isProd &amp;&amp; format === 'iife' ) ? computeIntroFor() : '', outro: '', sourcemap: !isProd, interop: 'auto', // danger zone exports: 'auto', amd: {}, indent: '\\t', strict: true } } ) } } return configs } /// Log Management function logLoadingTask( filename ) { if ( !isDebugging ) { return } const taskPath = relative( packageRootDirectory, filename ) const taskName = basename( filename, '.task.mjs' ) log( `Loading ${ green( taskPath ) } with task ${ blue( taskName ) }` ) } /// function IndenterFactory( indentationChar = '\\t', indentationLevel = 5 ) { const indentationLevels = {} let currentProperty = 'I_' for ( let currentIndentationLevel = 1 ; currentIndentationLevel &lt;= indentationLevel ; currentIndentationLevel++ ) { indentationLevels[ currentProperty ] = indentationChar.repeat( currentIndentationLevel ) currentProperty += '_' } return { I: new Indenter( indentationChar ), ...indentationLevels } } class Indenter { constructor( indentationChar = '\\t' ) { this.indentationChar = indentationChar this.currentIndentationLevel = 0 } _( indentationLevel = null ) { return this.indentationChar.repeat( indentationLevel ?? this.currentIndentationLevel ) } deeper( level = 1 ) { this.currentIndentationLevel += level } shallower( level = 1 ) { this.currentIndentationLevel -= level } } /// export { iteePackageRootDirectory, iteePackageJsonPath, iteePackageConfigurationsDirectory, iteePackageNodeModulesDirectory, iteePackageSourcesDirectory, packageRootDirectory, packageTasksDirectory, packageTasksConfigurationsDirectory, packageNodeModulesDirectory, packageBuildsDirectory, packageSourcesDirectory, packageSourcesBackendDirectory, packageSourcesCommonDirectory, packageSourcesFrontendDirectory, packageTestsDirectory, packageTestsBenchmarksDirectory, packageTestsBundlesDirectory, packageTestsUnitsDirectory, packageDocsDirectory, packageTutorialsDirectory, packageJsonPath, packageJson, packageName, packageVersion, packageDescription, packageAuthor, packageLicense, getPrettyPackageName, getPrettyPackageVersion, getPrettyNodeVersion, getPrettyNpmVersion, createDirectoryIfNotExist, getJsonFrom, createFile, getFilesFrom, getTasksFrom, serializeTasksFrom, parallelizeTasksFrom, getTaskConfigurationPathFor, getTaskConfigurationFor, getPrettyFormatForBanner, convertBannerIntoComment, computeBannerFor, computeIntroFor, createRollupConfigs, logLoadingTask, IndenterFactory as Indenter } × Search results Close "},"cleans_clean.task.mjs.html":{"id":"cleans_clean.task.mjs.html","title":"Source: cleans/clean.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: cleans/clean.task.mjs import colors from 'ansi-colors' import { deleteAsync } from 'del' import log from 'fancy-log' import { basename } from 'node:path' import { getTaskConfigurationFor, logLoadingTask } from '../_utils.mjs' logLoadingTask( import.meta.filename ) const { red } = colors const configuration = await getTaskConfigurationFor( import.meta.filename ) /** * @method npm run clean * @global * @description Will delete builds and temporary folders */ const cleanTask = () =&gt; deleteAsync( configuration, { onProgress: progress =&gt; { const path = progress.path || 'Nothing to clean...' const percent = Math.round( progress.percent * 100 ) const spacer = percent === 100 ? '' : ' ' log( `Deleting [${ progress.deletedCount }/${ progress.totalCount }]&lt;${ percent }%&gt;${ spacer }:`, red( path ) ) } } ) cleanTask.displayName = basename( import.meta.filename, '.task.mjs' ) cleanTask.description = 'Will delete builds and temporary folders' cleanTask.flags = null export { cleanTask } × Search results Close "},"helps_help.task.mjs.html":{"id":"helps_help.task.mjs.html","title":"Source: helps/help.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: helps/help.task.mjs import colors from 'ansi-colors' import log from 'fancy-log' import { basename } from 'node:path' import { getPrettyNodeVersion, getPrettyNpmVersion, getPrettyPackageName, getPrettyPackageVersion, Indenter, logLoadingTask } from '../_utils.mjs' logLoadingTask( import.meta.filename ) const { red, green, blue, cyan, yellow, magenta, unstyle } = colors function alignTextCenter( text, width ) { const unstyledText = unstyle( text.repeat( 1 ) ) const marginLength = ( width - unstyledText.length ) / 2 let leftMargin, rightMargin if ( Number.isInteger( marginLength ) ) { leftMargin = marginLength rightMargin = marginLength } else { const flooredMargin = Math.floor( marginLength ) leftMargin = flooredMargin rightMargin = flooredMargin + 1 } return ' '.repeat( leftMargin ) + text + ' '.repeat( rightMargin ) } function alignTextLeft( text, width ) { const unstyledText = unstyle( text.repeat( 1 ) ) let repeatTime = width - unstyledText.length repeatTime = ( repeatTime &gt; 0 ) ? repeatTime : 0 return text + ' '.repeat( repeatTime ) } function alignTextRight( text, width ) { const unstyledText = unstyle( text.repeat( 1 ) ) let repeatTime = width - unstyledText.length repeatTime = ( repeatTime &gt; 0 ) ? repeatTime : 0 return ' '.repeat( repeatTime ) + text } /** * @method npm run help ( default ) * @global * @description Will display the help in console */ const helpTask = ( done ) =&gt; { const bannerWidth = 70 const prettyPackageName = getPrettyPackageName() const prettyPackageVersion = getPrettyPackageVersion() const prettyNodeVersion = getPrettyNodeVersion() const prettyNpmVersion = getPrettyNpmVersion() const tableCharset = { topLeftCorner: '┏', topRightCorner: '┓', bottomRightCorner: '┛', bottomLeftCorner: '┗', horizontalBorder: '━', horizontalSeparator: '─', leftJoinSeparator: '┠', rightJoinSeparator: '┨', verticalBorder: '┃', verticalSeparator: '', } const mainBorder = tableCharset.horizontalBorder.repeat( bannerWidth ) const thinBorder = tableCharset.horizontalSeparator.repeat( bannerWidth ) const tableTop = `${ tableCharset.topLeftCorner }${ mainBorder }${ tableCharset.topRightCorner }` const tableSeparator = `${ tableCharset.leftJoinSeparator }${ thinBorder }${ tableCharset.rightJoinSeparator }` const tableBottom = `${ tableCharset.bottomLeftCorner }${ mainBorder }${ tableCharset.bottomRightCorner }` const tableLine = ( innerText ) =&gt; `${ tableCharset.verticalBorder }${ innerText }${ tableCharset.verticalBorder }` const { I_, I__, I___, I____, } = new Indenter( '\\t', 4 ) const npmRun = blue( 'npm run' ) log( '' ) log( tableTop ) log( tableLine( alignTextCenter( 'HELP', bannerWidth ) ) ) log( tableLine( alignTextCenter( prettyPackageName, bannerWidth ) ) ) log( tableLine( alignTextCenter( prettyPackageVersion, bannerWidth ) ) ) log( tableSeparator ) log( tableLine( alignTextLeft( prettyNodeVersion, bannerWidth ) ) ) log( tableLine( alignTextLeft( prettyNpmVersion, bannerWidth ) ) ) log( tableBottom ) log( I_, 'Available commands are:' ) log( I__, npmRun, cyan( 'help' ), '- Display this help.' ) log( I__, npmRun, cyan( 'patch' ), '- Will apply some patch/replacements in dependencies.', red( '(Apply only once after run \"npm install\")' ) ) log( I__, npmRun, cyan( 'clean' ), '- Will delete builds and temporary folders.' ) log( I__, npmRun, cyan( 'lint' ), '- Will run the eslint in pedantic mode with auto fix when possible.' ) log( I__, npmRun, cyan( 'doc' ), '- Will run jsdoc, and create documentation under `documentation` folder, using the docdash theme' ) log( I__, npmRun, cyan( 'test' ), '- Will run the test framworks (unit and bench), and create reports under `documentation/report` folder, using the mochawesome theme' ) log( I__, npmRun, cyan( 'unit' ), '- Will run the karma server for unit tests.' ) log( I__, npmRun, cyan( 'bench' ), '- Will run the karma server for benchmarks.' ) log( I__, npmRun, cyan( 'build' ), yellow( '--' ), green( '&lt;options&gt;' ), '- Will build the application for development and/or production environments.' ) log( I___, yellow( 'Note: The two dash are only required if you provide options !' ) ) log( I___, 'The available', green( '&lt;options&gt;' ), 'are:' ) log( I____, green( '-i' ), 'or', green( '--input' ), '- The main file path to build', cyan( '[Default: \"sources/main.js\"]' ), '.' ) log( I____, green( '-o' ), 'or', green( '--output' ), '- The folder where output the build', cyan( '[Default: \"builds\"]' ), '.' ) log( I____, green( '-f:' ), magenta( '&lt;format&gt;' ), 'or', green( '--format:' ), magenta( '&lt;format&gt;' ), ' - to specify the output build type. Where format could be any of:', magenta( 'cjs, esm, iife, umd' ), '.' ) log( I____, green( '-e:' ), magenta( '&lt;env&gt;' ), 'or', green( '--env:' ), magenta( '&lt;env&gt;' ), ' - to specify the build environment. Where env could be any of:', magenta( 'dev' ), magenta( 'prod' ), cyan( '[Default: \"dev\"]' ), '.' ) log( I____, green( '-s' ), 'or', green( '--sourcemap' ), ' - to build with related source map', cyan( '[Default: true]' ), '.' ) log( I____, green( '-t' ), 'or', green( '--treeshake' ), ' - allow to perform treeshaking when building', cyan( '[Default: true]' ), '.' ) log( I__, npmRun, cyan( 'release' ), '- Will run all the lint, test stuff, and if succeed will build the application.' ) log( '' ) log( I_, 'In case you have', blue( 'gulp' ), 'installed globally, you could use also:' ) log( I__, blue( 'gulp' ), cyan( 'command' ), '- It will perform the command like using \"npm run\" but with less characters to type... Because you\\'re a developer, right ?' ) log( '' ) done() } helpTask.displayName = basename( import.meta.filename, '.task.mjs' ) helpTask.description = 'Display the package help' helpTask.flags = null export { helpTask } × Search results Close "},"lints_lint.task.mjs.html":{"id":"lints_lint.task.mjs.html","title":"Source: lints/lint.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: lints/lint.task.mjs import colors from 'ansi-colors' import log from 'fancy-log' import child_process from 'node:child_process' import { basename } from 'node:path' import { promisify } from 'node:util' import { getTaskConfigurationPathFor, logLoadingTask } from '../_utils.mjs' logLoadingTask( import.meta.filename ) const execFile = promisify( child_process.execFile ) const { red } = colors /** * @method npm run lint * @global * @description Will lint the sources files and try to fix the style when possible */ const lintTask = async ( done ) =&gt; { try { const configurationPath = getTaskConfigurationPathFor( import.meta.filename ) const { stdout } = await execFile( 'npx', [ 'eslint', '--config', configurationPath, '--fix' ] ) if ( stdout !== '' ) { log( stdout ) } done() } catch ( error ) { log( error.stdout ) done( red( error.message ) ) } } lintTask.displayName = basename( import.meta.filename, '.task.mjs' ) lintTask.description = 'Will lint the sources files and try to fix the style when possible.' lintTask.flags = null export { lintTask } × Search results Close "},"patches_patch.task.mjs.html":{"id":"patches_patch.task.mjs.html","title":"Source: patches/patch.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: patches/patch.task.mjs import colors from 'ansi-colors' import log from 'fancy-log' import { readFileSync, writeFileSync } from 'node:fs' import { relative } from 'node:path' import { packageRootDirectory } from '../_utils.mjs' const { green, blue } = colors /** * @method npm run patch * @global * @description Will apply some patch/replacements in dependencies */ const patchTask = ( done ) =&gt; { // patch jsdoc { const jsdocFilePath = 'node_modules/jsdoc/cli.js' const searchValue = 'case \\'.js\\':' const replaceValue = '' + 'case \\'.mjs\\':' + '\\n' + '\\t\\t\\t\\t\\t' + 'config = require( path.resolve(confPath) ).default || {};' + '\\n' + '\\t\\t\\t\\t\\t' + 'break;' + '\\n' + '\\t\\t\\t\\t' + 'case \\'.js\\':' + '\\n' + '\\t\\t\\t\\t' + 'case \\'.cjs\\':' const fileContent = readFileSync( jsdocFilePath ).toString() const patchedFileContent = fileContent.replace( searchValue, replaceValue ) writeFileSync( jsdocFilePath, patchedFileContent ) } done() } patchTask.displayName = 'patch' patchTask.description = 'Will apply some patch/replacements in dependencies' patchTask.flags = null log( 'Loading ', green( relative( packageRootDirectory, import.meta.filename ) ), `with task ${ blue( patchTask.displayName ) }` ) export { patchTask } × Search results Close "},"releases_release.task.mjs.html":{"id":"releases_release.task.mjs.html","title":"Source: releases/release.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: releases/release.task.mjs import { series } from 'gulp' import { basename } from 'node:path' import { logLoadingTask } from '../_utils.mjs' import { buildTask } from '../builds/build.task.mjs' import { cleanTask } from '../cleans/clean.task.mjs' import { docTask } from '../docs/doc.task.mjs' import { lintTask } from '../lints/lint.task.mjs' import { computeBenchmarksTask } from '../tests/benchmarks/compute-benchmarks.task.mjs' import { runTestsTask } from '../tests/run-tests.task.mjs' import { computeUnitTestsTask } from '../tests/units/compute-unit-tests.task.mjs' logLoadingTask( import.meta.filename ) /** * @method npm run release * @global * @description Will perform a complete release of the library including 'clean', 'lint', 'doc', 'build-tests', 'test' and finally 'build'. */ const releaseTask = series( cleanTask, buildTask, computeBenchmarksTask, computeUnitTestsTask, runTestsTask, lintTask, docTask, ) releaseTask.displayName = basename( import.meta.filename, '.task.mjs' ) releaseTask.description = 'Will perform a complete release of the library including \\'clean\\', \\'lint\\', \\'doc\\', \\'test\\' and finally \\'build\\'.' releaseTask.flags = null export { releaseTask } × Search results Close "},"tests_run-tests.task.mjs.html":{"id":"tests_run-tests.task.mjs.html","title":"Source: tests/run-tests.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/run-tests.task.mjs import { series } from 'gulp' import { basename } from 'node:path' import { logLoadingTask } from '../_utils.mjs' import { runBenchmarksTestsTask } from './benchmarks/run-benchmarks.task.mjs' import { runUnitTestsTask } from './units/run-unit-tests.task.mjs' logLoadingTask( import.meta.filename ) /** * @method npm run test * @global * @description Will run unit tests and benchmarks for backend (node) and frontend (web-test-runner) environments */ const runTestsTask = series( runBenchmarksTestsTask, runUnitTestsTask, ) runTestsTask.displayName = basename( import.meta.filename, '.task.mjs' ) runTestsTask.description = 'Will run unit tests and benchmarks for backend (node) and frontend (web-test-runner) environments.' runTestsTask.flags = null export { runTestsTask } × Search results Close "},"tests_benchmarks_run-benchmarks-for-backend.task.mjs.html":{"id":"tests_benchmarks_run-benchmarks-for-backend.task.mjs.html","title":"Source: tests/benchmarks/run-benchmarks-for-backend.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/benchmarks/run-benchmarks-for-backend.task.mjs import colors from 'ansi-colors' import log from 'fancy-log' import { existsSync } from 'fs' import { basename } from 'node:path' import { join } from 'path' import { logLoadingTask, packageName, packageTestsBenchmarksDirectory } from '../../_utils.mjs' logLoadingTask( import.meta.filename ) const { red, yellow } = colors /** * @description Will run benchmarks with node */ const runBenchmarksForBackendTask = async ( done ) =&gt; { const benchesPath = join( packageTestsBenchmarksDirectory, `/${ packageName }.benchmarks.js` ) if ( !existsSync( benchesPath ) ) { log( yellow( `${ benchesPath } does not exist, skip backend benchmarks...` ) ) done() return } try { await import(benchesPath) done() } catch ( error ) { done( red( error ) ) } } runBenchmarksForBackendTask.displayName = basename( import.meta.filename, '.task.mjs' ) runBenchmarksForBackendTask.description = 'Will run benchmarks with node' runBenchmarksForBackendTask.flags = null export { runBenchmarksForBackendTask } × Search results Close "},"tests_benchmarks_run-benchmarks-for-frontend.task.mjs.html":{"id":"tests_benchmarks_run-benchmarks-for-frontend.task.mjs.html","title":"Source: tests/benchmarks/run-benchmarks-for-frontend.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/benchmarks/run-benchmarks-for-frontend.task.mjs import { startTestRunner } from '@web/test-runner' import colors from 'ansi-colors' import { basename } from 'node:path' import { getTaskConfigurationFor, logLoadingTask } from '../../_utils.mjs' logLoadingTask( import.meta.filename ) const { red } = colors /** * @description Will run benchmarks with web-test-runner */ const runBenchmarksForFrontendTask = () =&gt; { return new Promise( async ( resolve, reject ) =&gt; { const configuration = await getTaskConfigurationFor( import.meta.filename ) const testRunner = await startTestRunner( { config: configuration, readCliArgs: false, readFileConfig: false, autoExitProcess: false, } ) if ( !testRunner ) { reject( red( 'Internal test runner error.' ) ) return } // To ensure that testRunner exit event won't be used by other instance of test runner, // we need to be sure that current test runner is ended testRunner.on( 'finished', () =&gt; { testRunner.stop() } ) testRunner.on( 'stopped', () =&gt; { resolve() } ) } ) } runBenchmarksForFrontendTask.displayName = basename( import.meta.filename, '.task.mjs' ) runBenchmarksForFrontendTask.description = 'Will run benchmarks with web-test-runner.' runBenchmarksForFrontendTask.flags = null export { runBenchmarksForFrontendTask } × Search results Close "},"tests_units_run-unit-tests-for-backend.task.mjs.html":{"id":"tests_units_run-unit-tests-for-backend.task.mjs.html","title":"Source: tests/units/run-unit-tests-for-backend.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/units/run-unit-tests-for-backend.task.mjs import colors from 'ansi-colors' import { spawn } from 'child_process' import log from 'fancy-log' import { existsSync } from 'fs' import { basename } from 'node:path' import { join } from 'path' import { logLoadingTask, packageName, packageNodeModulesDirectory, packageTestsUnitsDirectory } from '../../_utils.mjs' logLoadingTask( import.meta.filename ) const { red, yellow, } = colors /** * @description Will run unit tests with node */ const runUnitTestsForBackendTask = ( done ) =&gt; { const testsPath = join( packageTestsUnitsDirectory, `/${ packageName }.units.mjs` ) if ( !existsSync( testsPath ) ) { log( yellow( `${ testsPath } does not exist, skip backend unit tests...` ) ) done() return } const mochaPath = join( packageNodeModulesDirectory, '/mocha/bin/mocha' ) const mocha = spawn( 'node', [ mochaPath, testsPath ], { stdio: 'inherit' } ) mocha.on( 'close', ( code ) =&gt; { ( code === 0 ) ? done() : done( red( `mocha exited with code ${ code }` ) ) } ) } runUnitTestsForBackendTask.displayName = basename( import.meta.filename, '.task.mjs' ) runUnitTestsForBackendTask.description = 'Will run unit tests with node' runUnitTestsForBackendTask.flags = null export { runUnitTestsForBackendTask } × Search results Close "},"tests_units_run-unit-tests-for-frontend.task.mjs.html":{"id":"tests_units_run-unit-tests-for-frontend.task.mjs.html","title":"Source: tests/units/run-unit-tests-for-frontend.task.mjs","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/units/run-unit-tests-for-frontend.task.mjs import { startTestRunner } from '@web/test-runner' import colors from 'ansi-colors' import { basename } from 'node:path' import { getTaskConfigurationFor, logLoadingTask } from '../../_utils.mjs' logLoadingTask( import.meta.filename ) const { red } = colors /** * @description Will run unit tests with web-test-runner */ const runUnitTestsForFrontendTask = () =&gt; { return new Promise( async ( resolve, reject ) =&gt; { const configuration = await getTaskConfigurationFor( import.meta.filename ) const testRunner = await startTestRunner( { config: configuration, readCliArgs: false, readFileConfig: false, autoExitProcess: false, } ) if ( !testRunner ) { reject( red( 'Internal test runner error.' ) ) return } // To ensure that testRunner exit event won't be used by other instance of test runner, // we need to be sure that current test runner is ended testRunner.on( 'finished', () =&gt; { testRunner.stop() } ) testRunner.on( 'stopped', () =&gt; { resolve() } ) } ) } runUnitTestsForFrontendTask.displayName = basename( import.meta.filename, '.task.mjs' ) runUnitTestsForFrontendTask.description = 'Will run unit tests with web-test-runner' runUnitTestsForFrontendTask.flags = null export { runUnitTestsForFrontendTask } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Global Members &lt;constant&gt; checkBundlingTask In view to detect bundling side effects this task will create intermediary file for each individual export from this package and then create rollup config for each of them and bundle Todo: Check for different targets env like next task below this one Source: tests/bundlings/check-bundling.task.mjs, line 16 Methods &lt;async&gt; checkBundlingFromEsmFilesDirectTask() In view to detect bundling side effects this task will create intermediary file for each individual export from this package and then create rollup config for each of them and bundle Todo: Check for different target env like next task below this one Source: tests/bundlings/check-bundling-from-esm-files-direct.task.mjs, line 37 &lt;async&gt; computeBenchmarksTask() Will generate benchmarks files from source code against provided alternatives Source: tests/benchmarks/compute-benchmarks.task.mjs, line 35 &lt;async&gt; computeUnitTestsTask() Will generate unit test files from source code using type inference from comments Source: tests/units/compute-unit-tests.task.mjs, line 37 &lt;generator&gt; createRollupConfigs(options) Will create an appropriate configuration object for rollup, related to the given arguments. Parameters: Name Type Description options Source: _utils.mjs, line 425 Returns: An array of rollup configuration Type Array.&lt;json&gt; npm run clean() Will delete builds and temporary folders Source: cleans/clean.task.mjs, line 15 npm run help () Will display the help in console Source: helps/help.task.mjs, line 64 npm run lint() Will lint the sources files and try to fix the style when possible Source: lints/lint.task.mjs, line 16 npm run patch() Will apply some patch/replacements in dependencies Source: patches/patch.task.mjs, line 15 npm run release() Will perform a complete release of the library including 'clean', 'lint', 'doc', 'build-tests', 'test' and finally 'build'. Source: releases/release.task.mjs, line 14 npm run test() Will run unit tests and benchmarks for backend (node) and frontend (web-test-runner) environments Source: tests/run-tests.task.mjs, line 9 &lt;async&gt; runBenchmarksForBackendTask() Will run benchmarks with node Source: tests/benchmarks/run-benchmarks-for-backend.task.mjs, line 22 runBenchmarksForFrontendTask() Will run benchmarks with web-test-runner Source: tests/benchmarks/run-benchmarks-for-frontend.task.mjs, line 16 runUnitTestsForBackendTask() Will run unit tests with node Source: tests/units/run-unit-tests-for-backend.task.mjs, line 24 runUnitTestsForFrontendTask() Will run unit tests with web-test-runner Source: tests/units/run-unit-tests-for-frontend.task.mjs, line 16 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" @itee/tasks v1.2.0 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTaskcreateRollupConfigsnpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask @itee/tasks × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
