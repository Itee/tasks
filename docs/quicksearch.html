<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"tests_bundlings_check-bundling-from-esm-files-direct.task.mjs.html":{"id":"tests_bundlings_check-bundling-from-esm-files-direct.task.mjs.html","title":"Source: tests/bundlings/check-bundling-from-esm-files-direct.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/bundlings/check-bundling-from-esm-files-direct.task.mjs import { existsSync, rmSync } from 'node:fs' import { basename, dirname, extname, join } from 'node:path' import { rollup } from 'rollup' import { green, magenta, red, } from '../../utils/colors.mjs' import { getJavascriptSourceFiles } from '../../utils/files.mjs' import { log, logLoadingTask } from '../../utils/loggings.mjs' import { packageSourcesDirectory, packageTestsBundlesDirectory } from '../../utils/packages.mjs' import { getTaskConfigurationFor } from '../../utils/tasks.mjs' logLoadingTask( import.meta.filename ) /** * @description In view to detect bundling side effects this task will * create intermediary file for each individual export from this package * and then create rollup config for each of them and bundle * Todo: Check for different target env like next task below this one */ const checkBundlingFromEsmFilesDirectTask = async ( done ) =&gt; { const outputDir = join( packageTestsBundlesDirectory, 'from_files_direct' ) if ( existsSync( outputDir ) ) { log( 'Clean up', magenta( outputDir ) ) rmSync( outputDir, { recursive: true } ) } const configuration = await getTaskConfigurationFor( import.meta.filename ) const sourceFiles = getJavascriptSourceFiles( configuration ) for ( let sourceFile of sourceFiles ) { const specificFilePath = sourceFile.replace( packageSourcesDirectory, '' ) const specificDir = dirname( specificFilePath ) const fileName = basename( sourceFile, extname( sourceFile ) ) const bundleFileName = `${ fileName }.bundle.js` const bundleFilePath = join( outputDir, specificDir, bundleFileName ) configuration.buildOptions.input = sourceFile configuration.buildOptions.output.file = bundleFilePath try { log( 'Bundling', green( configuration.buildOptions.output.file ) ) const bundle = await rollup( configuration.buildOptions ) await bundle.generate( configuration.buildOptions.output ) await bundle.write( configuration.buildOptions.output ) } catch ( error ) { log( red( error.message ) ) } } done() } checkBundlingFromEsmFilesDirectTask.displayName = basename( import.meta.filename, '.task.mjs' ) checkBundlingFromEsmFilesDirectTask.description = 'In view to detect bundling side effects this task will create intermediary file for each individual export from this package and then create rollup config for each of them and bundle' checkBundlingFromEsmFilesDirectTask.flags = null export { checkBundlingFromEsmFilesDirectTask } × Search results Close "},"tests_bundlings_check-bundling.task.mjs.html":{"id":"tests_bundlings_check-bundling.task.mjs.html","title":"Source: tests/bundlings/check-bundling.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/bundlings/check-bundling.task.mjs import { series } from 'gulp' import { basename } from 'node:path' import { logLoadingTask } from '../../utils/loggings.mjs' import { checkBundlingFromEsmBuildImportTask } from './check-bundling-from-esm-build-import.task.mjs' import { checkBundlingFromEsmFilesDirectTask } from './check-bundling-from-esm-files-direct.task.mjs' import { checkBundlingFromEsmFilesImportTask } from './check-bundling-from-esm-files-import.task.mjs' logLoadingTask( import.meta.filename ) /** * @description In view to detect bundling side effects this task will * create intermediary file for each individual export from this package * and then create rollup config for each of them and bundle * Todo: Check for different targets env like next task below this one */ const checkBundlingTask = series( checkBundlingFromEsmFilesImportTask, checkBundlingFromEsmBuildImportTask, checkBundlingFromEsmFilesDirectTask ) checkBundlingTask.displayName = basename( import.meta.filename, '.task.mjs' ) checkBundlingTask.description = 'In view to detect bundling side effects this task will create intermediary file for each individual export and then try to bundle them.' export { checkBundlingTask } × Search results Close "},"tests_benchmarks_compute-benchmarks.task.mjs.html":{"id":"tests_benchmarks_compute-benchmarks.task.mjs.html","title":"Source: tests/benchmarks/compute-benchmarks.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/benchmarks/compute-benchmarks.task.mjs import childProcess from 'node:child_process' import { basename, dirname, extname, join, relative } from 'node:path' import { red, yellow } from '../../utils/colors.mjs' import { createDirectoryIfNotExist, createFile, getJavascriptSourceFiles, } from '../../utils/files.mjs' import { log, logLoadingTask } from '../../utils/loggings.mjs' import { getUnscopedPackageName, packageNodeModulesDirectory, packageSourcesDirectory, packageTestsBenchmarksDirectory, packageTestsDirectory } from '../../utils/packages.mjs' import { getTaskConfigurationFor } from '../../utils/tasks.mjs' import { toCamelCase } from '../../utils/texts.mjs' logLoadingTask( import.meta.filename ) /** * @description Will generate benchmarks files from source code against provided alternatives */ const computeBenchmarksTask = async ( done ) =&gt; { createDirectoryIfNotExist( packageTestsBenchmarksDirectory ) // Get task configuration const filePathsToIgnore = await getTaskConfigurationFor( import.meta.filename ) const sourceFiles = getJavascriptSourceFiles( filePathsToIgnore ) const benchRootImports = [] for ( let sourceFile of sourceFiles ) { const specificFilePath = sourceFile.replace( packageSourcesDirectory, '' ) const specificDir = dirname( specificFilePath ) const fileName = basename( sourceFile, extname( sourceFile ) ) const camelCaseFileName = toCamelCase( fileName ) const benchFileName = `${ camelCaseFileName }.bench.js` const benchDirPath = join( packageTestsBenchmarksDirectory, specificDir ) const benchFilePath = join( benchDirPath, benchFileName ) const nsName = `${ camelCaseFileName }Namespace` const importDirPath = relative( benchDirPath, packageSourcesDirectory ) const importFilePath = join( importDirPath, specificFilePath ).replace( /\\\\/g, '/' ) try { const jsdocPath = join( packageNodeModulesDirectory, '/jsdoc/jsdoc.js' ) const jsdocOutput = childProcess.execFileSync( 'node', [ jsdocPath, '--explain', sourceFile ] ).toString() if ( jsdocOutput.includes( 'There are no input files to process' ) ) { log( 'Error ', red( `${ sourceFile }, no input files to process` ) ) continue } const classNames = [] const usedLongnames = [] const jsonData = JSON.parse( jsdocOutput ).filter( data =&gt; { const longName = data.longname const kind = data.kind if ( kind !== 'function' ) { if ( kind === 'class' &amp;&amp; !classNames.includes( longName ) ) { classNames.push( longName ) } return false } // We don't care that data bloc have comment they are unused to generate benchmarks // const undocumented = data.undocumented // if ( undocumented ) { // return false // } const scope = data.scope if ( ![ 'global', 'static' ].includes( scope ) ) { return false } if ( longName.includes( ' ' ) || longName.includes( '~' ) || usedLongnames.includes( longName ) ) { return false } for ( let className of classNames ) { if ( longName.includes( className ) ) { return false } } usedLongnames.push( longName ) return true } ) if ( jsonData.length === 0 ) { log( 'Ignoring', yellow( `${ sourceFile }, no usable exports found` ) ) continue } // Compute benchmark suites by grouping logically function by name[_x] const suiteGroups = {} for ( let docData of jsonData ) { try { const functionName = docData.name const nameSplits = functionName.split( '_' ) const rootName = nameSplits[ 0 ] if ( !( rootName in suiteGroups ) ) { suiteGroups[ rootName ] = [] } suiteGroups[ rootName ].push( functionName ) } catch ( error ) { log( red( error.message ) ) } } // Generate suites let benchSuites = '' const suitesToExports = [] for ( let suiteGroupName in suiteGroups ) { suitesToExports.push( `${ suiteGroupName }Suite` ) benchSuites += `const ${ suiteGroupName }Suite = Benchmark.Suite( '${ nsName }.${ suiteGroupName }', Testing.createSuiteOptions() )` + '\\n' for ( let suiteGroupValue of suiteGroups[ suiteGroupName ] ) { benchSuites += ` .add( '${ suiteGroupValue }()', Testing.iterateOverDataMap( ${ nsName }.${ suiteGroupValue } ), Testing.createBenchmarkOptions() )` + '\\n' } benchSuites += '\\n' } // compute relative level to get import wrappers const wrapperDirPath = relative( benchDirPath, packageTestsDirectory ) const importBenchmarkFilePath = join( wrapperDirPath, 'import.benchmarks.js' ) const importTestingFilePath = join( wrapperDirPath, 'import.testing.js' ) const template = '' + `import * as ${ nsName } from '${ importFilePath }'` + '\\n' + `import { getBenchmarkPackage } from '${ importBenchmarkFilePath }'` + '\\n' + `import { getTestingPackage } from '${ importTestingFilePath }'` + '\\n' + '\\n' + `const Benchmark = await getBenchmarkPackage()` + '\\n' + `const Testing = await getTestingPackage()` + '\\n' + '\\n' + `${ benchSuites }` + // '\\n' + `export { ${ suitesToExports } }` + '\\n' + '\\n' const importBenchFilePath = relative( packageTestsBenchmarksDirectory, benchFilePath ).replace( /\\\\/g, '/' ) benchRootImports.push( { path: importBenchFilePath, exports: suitesToExports } ) createDirectoryIfNotExist( benchDirPath ) createFile( benchFilePath, template ) } catch ( error ) { log( red( error.message ) ) } } let templateImports = '' let suites = [] for ( let i = 0 ; i &lt; benchRootImports.length ; i++ ) { const currentBench = benchRootImports[ i ] const namedExports = currentBench.exports const imports = namedExports.join( ', ' ) suites.push( ...namedExports ) templateImports += `import {${ imports }} from './${ currentBench.path }'` + '\\n' } // Use a fallback in case no benches were found at all if ( benchRootImports.length === 0 ) { log( 'Warning ', yellow( 'No usable exports found, generate default file to avoid frontend breakage.' ) ) const defaultBenchesDir = join( packageTestsBenchmarksDirectory, 'default' ) const defaultBenchesPath = join( defaultBenchesDir, 'default.bench.js' ) createDirectoryIfNotExist( defaultBenchesDir ) createFile( defaultBenchesPath, '// Avoid web test runner crash on empty benches' ) } const benchesTemplate = '' + `${ templateImports }` + '\\n' + 'const suites = [' + '\\n' + `${ suites.map( suite =&gt; `\\t${ suite }` ).join( ',\\n' ) }` + '\\n' + ']' + '\\n' + '\\n' + `for ( const suite of suites ) {` + '\\n' + `\\tsuite.run()` + '\\n' + `}` + '\\n' const benchesFilePath = join( packageTestsBenchmarksDirectory, `${ getUnscopedPackageName() }.benchmarks.js` ) createFile( benchesFilePath, benchesTemplate ) done() } computeBenchmarksTask.displayName = basename( import.meta.filename, '.task.mjs' ) computeBenchmarksTask.description = 'Will generate benchmarks files from source code against provided alternatives.' computeBenchmarksTask.flags = null export { computeBenchmarksTask } × Search results Close "},"tests_units_compute-unit-tests.task.mjs.html":{"id":"tests_units_compute-unit-tests.task.mjs.html","title":"Source: tests/units/compute-unit-tests.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/units/compute-unit-tests.task.mjs import { isNotEmptyArray } from 'itee-validators' import childProcess from 'node:child_process' import { basename, dirname, extname, join, relative } from 'node:path' import { red, yellow } from '../../utils/colors.mjs' import { createDirectoryIfNotExist, createFile, getJavascriptSourceFiles } from '../../utils/files.mjs' import { log, logLoadingTask } from '../../utils/loggings.mjs' import { getPrettyPackageName, getUnscopedPackageName, packageNodeModulesDirectory, packageSourcesDirectory, packageTestsUnitsDirectory } from '../../utils/packages.mjs' import { getTaskConfigurationFor } from '../../utils/tasks.mjs' import { Indenter, toCamelCase } from '../../utils/texts.mjs' logLoadingTask( import.meta.filename ) /** * @description Will generate unit test files from source code using type inference from comments */ const computeUnitTestsTask = async ( done ) =&gt; { createDirectoryIfNotExist( packageTestsUnitsDirectory ) const filePathsToIgnore = await getTaskConfigurationFor( import.meta.filename ) const sourceFiles = getJavascriptSourceFiles( filePathsToIgnore ) const unitsImportMap = [] for ( let sourceFile of sourceFiles ) { const specificFilePath = sourceFile.replace( packageSourcesDirectory, '' ) const specificDir = dirname( specificFilePath ) const fileName = basename( sourceFile, extname( sourceFile ) ) const camelCaseFileName = toCamelCase( fileName ) const unitFileName = `${ camelCaseFileName }.unit.mjs` const unitDirPath = join( packageTestsUnitsDirectory, specificDir ) const unitFilePath = join( unitDirPath, unitFileName ) const nsName = `${ camelCaseFileName }Namespace` const unitName = `${ camelCaseFileName }Units` const importDirPath = relative( unitDirPath, packageSourcesDirectory ) const importFilePath = join( importDirPath, specificFilePath ).replace( /\\\\/g, '/' ) try { const jsdocPath = join( packageNodeModulesDirectory, '/jsdoc/jsdoc.js' ) const jsdocOutput = childProcess.execFileSync( 'node', [ jsdocPath, '--explain', sourceFile ] ).toString() if ( jsdocOutput.includes( 'There are no input files to process' ) ) { log( 'Error ', red( `${ sourceFile }, no input files to process` ) ) continue } const classNames = [] const usedLongnames = [] const jsonData = JSON.parse( jsdocOutput ).filter( data =&gt; { const longName = data.longname const kind = data.kind if ( kind !== 'function' ) { if ( kind === 'class' &amp;&amp; !classNames.includes( longName ) ) { classNames.push( longName ) } return false } const undocumented = data.undocumented if ( undocumented ) { return false } const scope = data.scope if ( ![ 'global', 'static' ].includes( scope ) ) { return false } if ( longName.includes( ' ' ) || longName.includes( '~' ) || usedLongnames.includes( longName ) ) { return false } for ( let className of classNames ) { if ( longName.includes( className ) ) { return false } } usedLongnames.push( longName ) return true } ) if ( jsonData.length === 0 ) { log( 'Ignoring', yellow( `${ sourceFile }, no usable exports found` ) ) continue } let describes = '' const { I, I_, I__, I___, } = new Indenter( '\\t', 3 ) for ( let docData of jsonData ) { try { //check input parameters and types const docParameters = docData.params || [] const parameters = [] for ( let pIndex = 0 ; pIndex &lt; docParameters.length ; pIndex++ ) { const param = docParameters[ pIndex ] let paramName = param.name if ( !paramName ) { paramName = `param${ pIndex }` log( yellow( `Missing parameter name for [${ docData.longname }]. Defaulting to [${ paramName }]` ) ) } const paramType = param.type if ( !paramType ) { throw new ReferenceError( `Missing parameter type. Unable to create unit test for [${ docData.longname }] !` ) } const parameter = { name: paramName, types: [] } const paramTypeNames = paramType.names for ( let type of paramTypeNames ) { parameter.types.push( type ) } parameters.push( parameter ) } // Check returns types const docReturns = docData.returns || [] const returns = [] for ( let docReturn of docReturns ) { const returnType = docReturn.type if ( !returnType ) { throw new ReferenceError( `Missing return type for [${ docData.longname }]. Ignore current target !` ) } returns.push( ...returnType.names ) } // Todo check throws // Get user define rules // const rules = [] // Infer basic rules const baseIndent = 2 let its = '' if ( parameters.length === 0 ) { if ( returns.length === 0 ) { const result = `${ I._( baseIndent + 1 ) }const result = ${ nsName }.${ docData.name }()` + '\\n' const expect = `${ I._( baseIndent + 1 ) }expect(result).to.be.a('undefined')` + '\\n' its += '' + `${ I._( baseIndent ) }it( 'should return undefined value on call', async function () {` + '\\n' + '\\n' + `${ result }` + `${ expect }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } else if ( returns.length === 1 ) { const firstReturnType = returns[ 0 ] const lowerName = firstReturnType.toLowerCase() const result = `${ I._( baseIndent + 1 ) }const result = ${ nsName }.${ docData.name }()` + '\\n' let expect = '' if ( lowerName.startsWith( 'array' ) ) { //todo array of... expect += `${ I._( baseIndent + 1 ) }expect(result).to.be.a('array')` + '\\n' } else { expect += `${ I._( baseIndent + 1 ) }expect(result).to.be.a('${ lowerName }')` + '\\n' } its += '' + `${ I._( baseIndent ) }it( 'should return value of type ${ lowerName }', async function() {` + '\\n' + '\\n' + `${ result }` + `${ expect }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } else { const result = `${ I._( baseIndent + 1 ) }const result = ${ nsName }.${ docData.name }()` + '\\n' let returnTypesLabel = [] let oneOf = [] for ( let returnType of returns ) { const lowerName = returnType.toLowerCase() returnTypesLabel.push( lowerName ) if ( lowerName.startsWith( 'array' ) ) { //todo array of... oneOf.push( 'array' ) } else { oneOf.push( `'${ lowerName }'` ) } } const underlyingType = `${ I._( baseIndent + 1 ) }const resultType = (result === null) ? 'null' : typeof result` + '\\n' const expect = `${ I._( baseIndent + 1 ) }expect(resultType).to.be.oneOf([${ oneOf.join( ',' ) }])` + '\\n' its += '' + `${ I._( baseIndent ) }it( 'should return value where type is ${ returnTypesLabel.join( ' or ' ) }', async function() {` + '\\n' + '\\n' + `${ result }` + `${ underlyingType }` + `${ expect }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } } else { if ( returns.length === 0 ) { let itDeclaration = [] let index = 0 let indent = baseIndent + 1 let localIndent = indent let dataSets = '' let forLoopOpens = '' let forLoopCloses = '' let args = [] for ( let parameter of parameters ) { const parameterType = parameter.types[ 0 ] itDeclaration.push( `${ parameter.name } is of type ${ parameterType }` ) dataSets += `${ I._( indent ) }const dataSet${ index } = _dataMap[ '${ parameterType }s' ]` + '\\n' // dataSets += `${ I._( indent ) }const dataSet${ index } = this._dataMap[ '${ parameterType }s' ]` + '\\n' forLoopOpens += '' + '\\n' + `${ I._( localIndent ) }for ( let key${ index } in dataSet${ index } ) {` + '\\n' + `${ I._( localIndent + 1 ) }const dataSetValue${ index } = dataSet${ index }[ key${ index } ]` + '\\n' args.push( `dataSetValue${ index }` ) forLoopCloses = `${ I._( localIndent ) }}` + '\\n' + `${ forLoopCloses }` index++ localIndent++ } const result = `${ I._( localIndent ) }const result = ${ nsName }.${ docData.name }( ${ args.join( ', ' ) } )` + '\\n' const expect = `${ I._( localIndent ) }expect(result).to.be.a('undefined')` + '\\n' const param = '' + `${ dataSets }` + `${ forLoopOpens }` + `${ result }` + `${ expect }` + `${ forLoopCloses }` its += '' + `${ I._( baseIndent ) }it( 'should return undefined value when ${ itDeclaration.join( ' and ' ) }', async function() {` + '\\n' + '\\n' + `${ param }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } else if ( returns.length === 1 ) { const firstReturnType = returns[ 0 ] const lowerName = firstReturnType.toLowerCase() let itDeclaration = [] let index = 0 let indent = baseIndent + 1 let localIndent = indent let dataSets = '' let forLoopOpens = '' let forLoopCloses = '' let args = [] for ( let parameter of parameters ) { const parameterType = parameter.types[ 0 ] const isAnyType = ( parameterType === '*' || parameterType.toLowerCase() === 'any' ) const declaration = ( isAnyType ) ? `${ parameter.name } is of any type` : `${ parameter.name } is of type ${ parameterType }` itDeclaration.push( declaration ) if ( isAnyType ) { dataSets += `${ I._( indent ) }const dataMap${ index } = _dataMap` + '\\n' + // dataSets += `${ I._( indent ) }const dataMap${ index } = this._dataMap` + '\\n' + `${ I._( localIndent ) }for ( let dataSetKey${ index } in dataMap${ index } ) {` + '\\n' localIndent++ dataSets += `${ I._( indent + 1 ) }const dataSet${ index } = dataMap${ index }[ dataSetKey${ index } ]` + '\\n' forLoopOpens += '' + '\\n' + `${ I._( localIndent ) }for ( let key${ index } in dataSet${ index } ) {` + '\\n' + `${ I._( localIndent + 1 ) }const dataSetValue${ index } = dataSet${ index }[ key${ index } ]` + '\\n' args.push( `dataSetValue${ index }` ) forLoopCloses = `${ I._( localIndent ) }}` + '\\n' + `${ I._( localIndent - 1 ) }}` + '\\n' + `${ forLoopCloses }` } else { dataSets += `${ I._( indent ) }const dataSet${ index } = _dataMap[ '${ parameterType }s' ]` + '\\n' // dataSets += `${ I._( indent ) }const dataSet${ index } = this._dataMap[ '${ parameterType }s' ]` + '\\n' forLoopOpens += '' + '\\n' + `${ I._( localIndent ) }for ( let key${ index } in dataSet${ index } ) {` + '\\n' + `${ I._( localIndent + 1 ) }const dataSetValue${ index } = dataSet${ index }[ key${ index } ]` + '\\n' args.push( `dataSetValue${ index }` ) forLoopCloses = `${ I._( localIndent ) }}` + '\\n' + `${ forLoopCloses }` } index++ localIndent++ } const result = `${ I._( localIndent ) }const result = ${ nsName }.${ docData.name }( ${ args.join( ', ' ) } )` + '\\n' let expect = '' if ( lowerName.startsWith( 'array' ) ) { expect = `${ I._( localIndent ) }expect(result).to.be.a('array')` + '\\n' //todo array of... } else { expect = `${ I._( localIndent ) }expect(result).to.be.a('${ lowerName }')` + '\\n' } const param = '' + `${ dataSets }` + `${ forLoopOpens }` + `${ result }` + `${ expect }` + `${ forLoopCloses }` its += '' + `${ I._( baseIndent ) }it( 'should return value of type ${ lowerName } when ${ itDeclaration.join( ' and ' ) }', async function() {` + '\\n' + '\\n' + `${ param }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } else { let itDeclaration = [] let index = 0 let indent = baseIndent + 1 let localIndent = indent let dataSets = '' let forLoopOpens = '' let forLoopCloses = '' let args = [] for ( let parameter of parameters ) { const parameterType = parameter.types[ 0 ] itDeclaration.push( `${ parameter.name } is of type ${ parameterType }` ) dataSets += `${ I._( localIndent ) }const dataSet${ index } = _dataMap[ '${ parameterType }s' ]` + '\\n' // dataSets += `${ I._( indent ) }const dataSet${ index } = this._dataMap[ '${ parameterType }s' ]` + '\\n' forLoopOpens += '' + '\\n' + `${ I._( localIndent ) }for ( let key${ index } in dataSet${ index } ) {` + '\\n' + `${ I._( localIndent + 1 ) }const dataSetValue${ index } = dataSet${ index }[ key${ index } ]` + '\\n' args.push( `dataSetValue${ index }` ) forLoopCloses = `${ I._( localIndent ) }}` + '\\n' + `${ forLoopCloses }` index++ localIndent++ } const result = `${ I._( localIndent + 1 ) }const result = ${ nsName }.${ docData.name }( ${ args.join( ', ' ) } )` + '\\n' let returnTypesLabel = [] let oneOf = [] for ( let returnType of returns ) { const lowerName = returnType.toLowerCase() returnTypesLabel.push( lowerName ) if ( lowerName.startsWith( 'array' ) ) { //todo array of... oneOf.push( 'array' ) } else { oneOf.push( `'${ lowerName }'` ) } } const underlyingType = `${ I._( localIndent + 1 ) }const resultType = (result === null) ? 'null' : typeof result` + '\\n' const expect = `${ I._( localIndent + 1 ) }expect(resultType).to.be.oneOf([${ oneOf.join( ',' ) }])` + '\\n' const param = '' + `${ dataSets }` + `${ forLoopOpens }` + `${ result }` + `${ underlyingType }` + `${ expect }` + `${ forLoopCloses }` its += '' + `${ I._( baseIndent ) }it( 'should return value of type ${ returnTypesLabel.join( ' or ' ) } when ${ itDeclaration.join( ' and ' ) }', async function() {` + '\\n' + '\\n' + `${ param }` + '\\n' + `${ I._( baseIndent ) }} )` + '\\n' } } describes += '' + `${ I_ }describe( '${ docData.name }()', function () {` + '\\n' + '\\n' + `${ I__ }it( 'should be bundlable', async function () {` + '\\n' + '\\n' + `${ I___ }expect(${ nsName }.${ docData.name }).to.exist` + '\\n' + '\\n' + `${ I__ }} )` + '\\n' + '\\n' + `${ its }` + '\\n' + `${ I_ }} )` + '\\n' + '\\n' } catch ( error ) { log( red( error.message ) ) } } const template = '' + `import { expect } from 'chai'` + '\\n' + `import { Testing } from 'itee-utils/sources/testings/benchmarks.js'` + '\\n' + `import * as ${ nsName } from '${ importFilePath }'` + '\\n' + '\\n' + `describe( '${ unitName }', function () {` + '\\n' + '\\n' + `${ I_ }let _dataMap` + '\\n' + `${ I_ }before( function() {` + '\\n' + `${ I__ }_dataMap = Testing.createDataMap()` + '\\n' + `${ I_ }} )` + '\\n' + '\\n' + `${ describes }` + '' + `} )` + '\\n' const importUnitFilePath = relative( packageTestsUnitsDirectory, unitFilePath ) unitsImportMap.push( { exportName: unitName, path: importUnitFilePath.replace( /\\\\/g, '/' ) } ) createDirectoryIfNotExist( unitDirPath ) createFile( unitFilePath, template ) } catch ( error ) { log( red( error.message ) ) } } // If some tests to import generate global units file let unitsTemplate if ( isNotEmptyArray( unitsImportMap ) ) { let computedImports = [] for ( let entry of unitsImportMap ) { // computedImports.push(`import { ${ entry.exportName } } from './${ entry.path }'`) computedImports.push( `export * from './${ entry.path }'` ) } unitsTemplate = computedImports.join( '\\n' ) } else { log( 'Warning ', yellow( 'No tests were generated. Create fallback global root import file.' ) ) const defaultUnitsDir = join( packageTestsUnitsDirectory, 'default' ) const defaultUnitsPath = join( defaultUnitsDir, 'default.unit.mjs' ) createDirectoryIfNotExist( defaultUnitsDir ) createFile( defaultUnitsPath, '// Avoid web test runner crash on empty benches' ) const prettyPackageName = getPrettyPackageName( '#' ) unitsTemplate = `describe( '${ prettyPackageName }', () =&gt; {} )` + '\\n' } const unitsFilePath = join( packageTestsUnitsDirectory, `${ getUnscopedPackageName() }.units.mjs` ) createFile( unitsFilePath, unitsTemplate ) done() } computeUnitTestsTask.displayName = basename( import.meta.filename, '.task.mjs' ) computeUnitTestsTask.description = 'Will generate unit test files from source code using type inference from comments' computeUnitTestsTask.flags = null export { computeUnitTestsTask } × Search results Close "},"cleans_clean.task.mjs.html":{"id":"cleans_clean.task.mjs.html","title":"Source: cleans/clean.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: cleans/clean.task.mjs import { deleteAsync } from 'del' import { basename } from 'node:path' import { red } from '../utils/colors.mjs' import { log, logLoadingTask } from '../utils/loggings.mjs' import { getTaskConfigurationFor } from '../utils/tasks.mjs' logLoadingTask( import.meta.filename ) const configuration = await getTaskConfigurationFor( import.meta.filename ) /** * @method npm run clean * @global * @description Will delete builds and temporary folders */ const cleanTask = () =&gt; deleteAsync( configuration, { onProgress: progress =&gt; { const path = progress.path || 'Nothing to clean...' const percent = Math.round( progress.percent * 100 ) const spacer = percent === 100 ? '' : ' ' log( `Deleting [${ progress.deletedCount }/${ progress.totalCount }]&lt;${ percent }%&gt;${ spacer }:`, red( path ) ) } } ) cleanTask.displayName = basename( import.meta.filename, '.task.mjs' ) cleanTask.description = 'Will delete builds and temporary folders' cleanTask.flags = null export { cleanTask } × Search results Close "},"helps_help.task.mjs.html":{"id":"helps_help.task.mjs.html","title":"Source: helps/help.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: helps/help.task.mjs import { basename } from 'node:path' import { blue, cyan, green, magenta, red, yellow } from '../utils/colors.mjs' import { log, logLoadingTask } from '../utils/loggings.mjs' import { getPrettyNodeVersion, getPrettyNpmVersion, getPrettyPackageName, getPrettyPackageVersion } from '../utils/packages.mjs' import { alignTextCenter, alignTextLeft, Indenter, } from '../utils/texts.mjs' logLoadingTask( import.meta.filename ) /** * @method npm run help ( default ) * @global * @description Will display the help in console */ const helpTask = ( done ) =&gt; { const bannerWidth = 70 const prettyPackageName = getPrettyPackageName() const prettyPackageVersion = getPrettyPackageVersion() const prettyNodeVersion = getPrettyNodeVersion() const prettyNpmVersion = getPrettyNpmVersion() const tableCharset = { topLeftCorner: '┏', topRightCorner: '┓', bottomRightCorner: '┛', bottomLeftCorner: '┗', horizontalBorder: '━', horizontalSeparator: '─', leftJoinSeparator: '┠', rightJoinSeparator: '┨', verticalBorder: '┃', verticalSeparator: '', } const mainBorder = tableCharset.horizontalBorder.repeat( bannerWidth ) const thinBorder = tableCharset.horizontalSeparator.repeat( bannerWidth ) const tableTop = `${ tableCharset.topLeftCorner }${ mainBorder }${ tableCharset.topRightCorner }` const tableSeparator = `${ tableCharset.leftJoinSeparator }${ thinBorder }${ tableCharset.rightJoinSeparator }` const tableBottom = `${ tableCharset.bottomLeftCorner }${ mainBorder }${ tableCharset.bottomRightCorner }` const tableLine = ( innerText ) =&gt; `${ tableCharset.verticalBorder }${ innerText }${ tableCharset.verticalBorder }` const { I_, I__, I___, I____, } = new Indenter( '\\t', 4 ) const npmRun = blue( 'npm run' ) log( '' ) log( tableTop ) log( tableLine( alignTextCenter( 'HELP', bannerWidth ) ) ) log( tableLine( alignTextCenter( prettyPackageName, bannerWidth ) ) ) log( tableLine( alignTextCenter( prettyPackageVersion, bannerWidth ) ) ) log( tableSeparator ) log( tableLine( alignTextLeft( prettyNodeVersion, bannerWidth ) ) ) log( tableLine( alignTextLeft( prettyNpmVersion, bannerWidth ) ) ) log( tableBottom ) log( I_, 'Available commands are:' ) log( I__, npmRun, cyan( 'help' ), '- Display this help.' ) log( I__, npmRun, cyan( 'patch' ), '- Will apply some patch/replacements in dependencies.', red( '(Apply only once after run \"npm install\")' ) ) log( I__, npmRun, cyan( 'clean' ), '- Will delete builds and temporary folders.' ) log( I__, npmRun, cyan( 'lint' ), '- Will run the eslint in pedantic mode with auto fix when possible.' ) log( I__, npmRun, cyan( 'doc' ), '- Will run jsdoc, and create documentation under `documentation` folder, using the docdash theme' ) log( I__, npmRun, cyan( 'test' ), '- Will run the test framworks (unit and bench), and create reports under `documentation/report` folder, using the mochawesome theme' ) log( I__, npmRun, cyan( 'unit' ), '- Will run the karma server for unit tests.' ) log( I__, npmRun, cyan( 'bench' ), '- Will run the karma server for benchmarks.' ) log( I__, npmRun, cyan( 'build' ), yellow( '--' ), green( '&lt;options&gt;' ), '- Will build the application for development and/or production environments.' ) log( I___, yellow( 'Note: The two dash are only required if you provide options !' ) ) log( I___, 'The available', green( '&lt;options&gt;' ), 'are:' ) log( I____, green( '-i' ), 'or', green( '--input' ), '- The main file path to build', cyan( '[Default: \"sources/main.js\"]' ), '.' ) log( I____, green( '-o' ), 'or', green( '--output' ), '- The folder where output the build', cyan( '[Default: \"builds\"]' ), '.' ) log( I____, green( '-f:' ), magenta( '&lt;format&gt;' ), 'or', green( '--format:' ), magenta( '&lt;format&gt;' ), ' - to specify the output build type. Where format could be any of:', magenta( 'cjs, esm, iife, umd' ), '.' ) log( I____, green( '-e:' ), magenta( '&lt;env&gt;' ), 'or', green( '--env:' ), magenta( '&lt;env&gt;' ), ' - to specify the build environment. Where env could be any of:', magenta( 'dev' ), magenta( 'prod' ), cyan( '[Default: \"dev\"]' ), '.' ) log( I____, green( '-s' ), 'or', green( '--sourcemap' ), ' - to build with related source map', cyan( '[Default: true]' ), '.' ) log( I____, green( '-t' ), 'or', green( '--treeshake' ), ' - allow to perform treeshaking when building', cyan( '[Default: true]' ), '.' ) log( I__, npmRun, cyan( 'release' ), '- Will run all the lint, test stuff, and if succeed will build the application.' ) log( '' ) log( I_, 'In case you have', blue( 'gulp' ), 'installed globally, you could use also:' ) log( I__, blue( 'gulp' ), cyan( 'command' ), '- It will perform the command like using \"npm run\" but with less characters to type... Because you\\'re a developer, right ?' ) log( '' ) done() } helpTask.displayName = basename( import.meta.filename, '.task.mjs' ) helpTask.description = 'Display the package help' helpTask.flags = null export { helpTask } × Search results Close "},"lints_lint.task.mjs.html":{"id":"lints_lint.task.mjs.html","title":"Source: lints/lint.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: lints/lint.task.mjs import child_process from 'node:child_process' import { basename } from 'node:path' import { promisify } from 'node:util' import { cyan, red } from '../utils/colors.mjs' import { log, logLoadingTask } from '../utils/loggings.mjs' import { getTaskConfigurationPathFor } from '../utils/tasks.mjs' logLoadingTask( import.meta.filename ) const execFile = promisify( child_process.execFile ) /** * @method npm run lint * @global * @description Will lint the sources files and try to fix the style when possible */ const lintTask = async ( done ) =&gt; { try { const configurationPath = getTaskConfigurationPathFor( import.meta.filename ) log( `Loading configuration from ${ cyan( configurationPath ) }` ) const { stdout } = await execFile( 'npx', [ 'eslint', '--config', configurationPath, '--fix' ] ) if ( stdout !== '' ) { log( stdout ) } done() } catch ( error ) { log( error.stdout ) done( red( error.message ) ) } } lintTask.displayName = basename( import.meta.filename, '.task.mjs' ) lintTask.description = 'Will lint the sources files and try to fix the style when possible.' lintTask.flags = null export { lintTask } × Search results Close "},"patches_patch.task.mjs.html":{"id":"patches_patch.task.mjs.html","title":"Source: patches/patch.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: patches/patch.task.mjs import { readFileSync, writeFileSync } from 'node:fs' import { basename } from 'node:path' import { logLoadingTask } from '../utils/loggings.mjs' logLoadingTask( import.meta.filename ) /** * @method npm run patch * @global * @description Will apply some patch/replacements in dependencies */ const patchTask = ( done ) =&gt; { // patch jsdoc { const jsdocFilePath = 'node_modules/jsdoc/cli.js' const searchValue = 'case \\'.js\\':' const replaceValue = '' + 'case \\'.mjs\\':' + '\\n' + '\\t\\t\\t\\t\\t' + 'config = require( path.resolve(confPath) ).default || {};' + '\\n' + '\\t\\t\\t\\t\\t' + 'break;' + '\\n' + '\\t\\t\\t\\t' + 'case \\'.js\\':' + '\\n' + '\\t\\t\\t\\t' + 'case \\'.cjs\\':' const fileContent = readFileSync( jsdocFilePath ).toString() const patchedFileContent = fileContent.replace( searchValue, replaceValue ) writeFileSync( jsdocFilePath, patchedFileContent ) } { const jsdocFilePath = 'node_modules/jsdoc/conf.json.EXAMPLE' const searchValue = '.js(doc|x)?' const replaceValue = '.(js|mjs|cjs|jsdoc|jsx)?' const fileContent = readFileSync( jsdocFilePath ).toString() const patchedFileContent = fileContent.replace( searchValue, replaceValue ) writeFileSync( jsdocFilePath, patchedFileContent ) } done() } patchTask.displayName = basename( import.meta.filename, '.task.mjs' ) patchTask.description = 'Will apply some patch/replacements in dependencies' patchTask.flags = null export { patchTask } × Search results Close "},"releases_release.task.mjs.html":{"id":"releases_release.task.mjs.html","title":"Source: releases/release.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: releases/release.task.mjs import { series } from 'gulp' import { basename } from 'node:path' import { buildTask } from '../builds/build.task.mjs' import { cleanTask } from '../cleans/clean.task.mjs' import { docTask } from '../docs/doc.task.mjs' import { lintTask } from '../lints/lint.task.mjs' import { computeBenchmarksTask } from '../tests/benchmarks/compute-benchmarks.task.mjs' import { runTestsTask } from '../tests/run-tests.task.mjs' import { computeUnitTestsTask } from '../tests/units/compute-unit-tests.task.mjs' import { logLoadingTask } from '../utils/loggings.mjs' logLoadingTask( import.meta.filename ) /** * @method npm run release * @global * @description Will perform a complete release of the library including 'clean', 'lint', 'doc', 'build-tests', 'test' and finally 'build'. */ const releaseTask = series( cleanTask, buildTask, computeBenchmarksTask, computeUnitTestsTask, runTestsTask, lintTask, docTask, ) releaseTask.displayName = basename( import.meta.filename, '.task.mjs' ) releaseTask.description = 'Will perform a complete release of the library including \\'clean\\', \\'lint\\', \\'doc\\', \\'test\\' and finally \\'build\\'.' releaseTask.flags = null export { releaseTask } × Search results Close "},"tests_run-tests.task.mjs.html":{"id":"tests_run-tests.task.mjs.html","title":"Source: tests/run-tests.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/run-tests.task.mjs import { series } from 'gulp' import { basename } from 'node:path' import { logLoadingTask } from '../utils/loggings.mjs' import { runBenchmarksTestsTask } from './benchmarks/run-benchmarks.task.mjs' import { runUnitTestsTask } from './units/run-unit-tests.task.mjs' logLoadingTask( import.meta.filename ) /** * @method npm run test * @global * @description Will run unit tests and benchmarks for backend (node) and frontend (web-test-runner) environments */ const runTestsTask = series( runBenchmarksTestsTask, runUnitTestsTask, ) runTestsTask.displayName = basename( import.meta.filename, '.task.mjs' ) runTestsTask.description = 'Will run unit tests and benchmarks for backend (node) and frontend (web-test-runner) environments.' runTestsTask.flags = null export { runTestsTask } × Search results Close "},"tests_benchmarks_run-benchmarks-for-backend.task.mjs.html":{"id":"tests_benchmarks_run-benchmarks-for-backend.task.mjs.html","title":"Source: tests/benchmarks/run-benchmarks-for-backend.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/benchmarks/run-benchmarks-for-backend.task.mjs import { existsSync } from 'node:fs' import { basename, join } from 'node:path' import { red, yellow } from '../../utils/colors.mjs' import { log, logLoadingTask } from '../../utils/loggings.mjs' import { getUnscopedPackageName, packageTestsBenchmarksDirectory } from '../../utils/packages.mjs' logLoadingTask( import.meta.filename ) /** * @description Will run benchmarks with node */ const runBenchmarksForBackendTask = async ( done ) =&gt; { const benchesPath = join( packageTestsBenchmarksDirectory, `/${ getUnscopedPackageName() }.benchmarks.js` ) if ( !existsSync( benchesPath ) ) { log( yellow( `${ benchesPath } does not exist, skip backend benchmarks...` ) ) done() return } try { await import(benchesPath) done() } catch ( error ) { done( red( error ) ) } } runBenchmarksForBackendTask.displayName = basename( import.meta.filename, '.task.mjs' ) runBenchmarksForBackendTask.description = 'Will run benchmarks with node' runBenchmarksForBackendTask.flags = null export { runBenchmarksForBackendTask } × Search results Close "},"tests_benchmarks_run-benchmarks-for-frontend.task.mjs.html":{"id":"tests_benchmarks_run-benchmarks-for-frontend.task.mjs.html","title":"Source: tests/benchmarks/run-benchmarks-for-frontend.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/benchmarks/run-benchmarks-for-frontend.task.mjs import { startTestRunner } from '@web/test-runner' import { basename } from 'node:path' import { red } from '../../utils/colors.mjs' import { logLoadingTask } from '../../utils/loggings.mjs' import { getTaskConfigurationFor } from '../../utils/tasks.mjs' logLoadingTask( import.meta.filename ) /** * @description Will run benchmarks with web-test-runner */ const runBenchmarksForFrontendTask = async () =&gt; { const configuration = await getTaskConfigurationFor( import.meta.filename ) const testRunner = await startTestRunner( { config: configuration, readCliArgs: false, readFileConfig: false, autoExitProcess: false, } ) return new Promise( ( resolve, reject ) =&gt; { if ( !testRunner ) { reject( red( 'Internal test runner error.' ) ) return } // To ensure that testRunner exit event won't be used by other instance of test runner, // we need to be sure that current test runner is ended testRunner.on( 'finished', () =&gt; { testRunner.stop() } ) testRunner.on( 'stopped', () =&gt; { resolve() } ) } ) } runBenchmarksForFrontendTask.displayName = basename( import.meta.filename, '.task.mjs' ) runBenchmarksForFrontendTask.description = 'Will run benchmarks with web-test-runner.' runBenchmarksForFrontendTask.flags = null export { runBenchmarksForFrontendTask } × Search results Close "},"tests_units_run-unit-tests-for-backend.task.mjs.html":{"id":"tests_units_run-unit-tests-for-backend.task.mjs.html","title":"Source: tests/units/run-unit-tests-for-backend.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/units/run-unit-tests-for-backend.task.mjs import { spawn } from 'node:child_process' import { existsSync } from 'node:fs' import { basename, join } from 'node:path' import { red, yellow } from '../../utils/colors.mjs' import { log, logLoadingTask } from '../../utils/loggings.mjs' import { getUnscopedPackageName, packageNodeModulesDirectory, packageTestsUnitsDirectory } from '../../utils/packages.mjs' logLoadingTask( import.meta.filename ) /** * @description Will run unit tests with node */ const runUnitTestsForBackendTask = ( done ) =&gt; { const testsPath = join( packageTestsUnitsDirectory, `/${ getUnscopedPackageName() }.units.mjs` ) if ( !existsSync( testsPath ) ) { log( yellow( `${ testsPath } does not exist, skip backend unit tests...` ) ) done() return } const mochaPath = join( packageNodeModulesDirectory, '/mocha/bin/mocha' ) const mocha = spawn( 'node', [ mochaPath, testsPath ], { stdio: 'inherit' } ) mocha.on( 'close', ( code ) =&gt; { ( code === 0 ) ? done() : done( red( `mocha exited with code ${ code }` ) ) } ) } runUnitTestsForBackendTask.displayName = basename( import.meta.filename, '.task.mjs' ) runUnitTestsForBackendTask.description = 'Will run unit tests with node' runUnitTestsForBackendTask.flags = null export { runUnitTestsForBackendTask } × Search results Close "},"tests_units_run-unit-tests-for-frontend.task.mjs.html":{"id":"tests_units_run-unit-tests-for-frontend.task.mjs.html","title":"Source: tests/units/run-unit-tests-for-frontend.task.mjs","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Source: tests/units/run-unit-tests-for-frontend.task.mjs import { startTestRunner } from '@web/test-runner' import { basename } from 'node:path' import { red } from '../../utils/colors.mjs' import { logLoadingTask } from '../../utils/loggings.mjs' import { getTaskConfigurationFor } from '../../utils/tasks.mjs' logLoadingTask( import.meta.filename ) /** * @description Will run unit tests with web-test-runner */ const runUnitTestsForFrontendTask = async () =&gt; { const configuration = await getTaskConfigurationFor( import.meta.filename ) const testRunner = await startTestRunner( { config: configuration, readCliArgs: false, readFileConfig: false, autoExitProcess: false, } ) return new Promise( ( resolve, reject ) =&gt; { if ( !testRunner ) { reject( red( 'Internal test runner error.' ) ) return } // To ensure that testRunner exit event won't be used by other instance of test runner, // we need to be sure that current test runner is ended testRunner.on( 'finished', () =&gt; { testRunner.stop() } ) testRunner.on( 'stopped', () =&gt; { resolve() } ) } ) } runUnitTestsForFrontendTask.displayName = basename( import.meta.filename, '.task.mjs' ) runUnitTestsForFrontendTask.description = 'Will run unit tests with web-test-runner' runUnitTestsForFrontendTask.flags = null export { runUnitTestsForFrontendTask } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask Global Members &lt;constant&gt; checkBundlingTask In view to detect bundling side effects this task will create intermediary file for each individual export from this package and then create rollup config for each of them and bundle Todo: Check for different targets env like next task below this one Source: tests/bundlings/check-bundling.task.mjs, line 16 Methods &lt;async&gt; checkBundlingFromEsmFilesDirectTask() In view to detect bundling side effects this task will create intermediary file for each individual export from this package and then create rollup config for each of them and bundle Todo: Check for different target env like next task below this one Source: tests/bundlings/check-bundling-from-esm-files-direct.task.mjs, line 36 &lt;async&gt; computeBenchmarksTask() Will generate benchmarks files from source code against provided alternatives Source: tests/benchmarks/compute-benchmarks.task.mjs, line 37 &lt;async&gt; computeUnitTestsTask() Will generate unit test files from source code using type inference from comments Source: tests/units/compute-unit-tests.task.mjs, line 41 npm run clean() Will delete builds and temporary folders Source: cleans/clean.task.mjs, line 14 npm run help () Will display the help in console Source: helps/help.task.mjs, line 28 npm run lint() Will lint the sources files and try to fix the style when possible Source: lints/lint.task.mjs, line 18 npm run patch() Will apply some patch/replacements in dependencies Source: patches/patch.task.mjs, line 10 npm run release() Will perform a complete release of the library including 'clean', 'lint', 'doc', 'build-tests', 'test' and finally 'build'. Source: releases/release.task.mjs, line 14 npm run test() Will run unit tests and benchmarks for backend (node) and frontend (web-test-runner) environments Source: tests/run-tests.task.mjs, line 9 &lt;async&gt; runBenchmarksForBackendTask() Will run benchmarks with node Source: tests/benchmarks/run-benchmarks-for-backend.task.mjs, line 24 &lt;async&gt; runBenchmarksForFrontendTask() Will run benchmarks with web-test-runner Source: tests/benchmarks/run-benchmarks-for-frontend.task.mjs, line 12 runUnitTestsForBackendTask() Will run unit tests with node Source: tests/units/run-unit-tests-for-backend.task.mjs, line 26 &lt;async&gt; runUnitTestsForFrontendTask() Will run unit tests with web-test-runner Source: tests/units/run-unit-tests-for-frontend.task.mjs, line 12 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Itee Tasks v1.3.2 Global checkBundlingFromEsmFilesDirectTaskcheckBundlingTaskcomputeBenchmarksTaskcomputeUnitTestsTasknpm run cleannpm run help ( default )npm run lintnpm run patchnpm run releasenpm run testrunBenchmarksForBackendTaskrunBenchmarksForFrontendTaskrunUnitTestsForBackendTaskrunUnitTestsForFrontendTask @itee/tasks × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
